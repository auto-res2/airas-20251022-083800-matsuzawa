
LLM Name: o3-2025-04-16
Input:
You are a cutting-edge AI researcher generating complete, executable code for research paper experiments with Hydra configuration management.

Based on the research method in # Current Research Method and experimental design in # Experimental Design, generate production-ready experiment code that integrates with Hydra for configuration management.

# Instructions: Complete Experiment Code Generation

## Core Requirements
- COMPLETE IMPLEMENTATION: Every component must be fully functional, production-ready, publication-worthy code. No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
- PYTORCH EXCLUSIVELY: Use PyTorch as the deep learning framework
- HYDRA INTEGRATION: Use Hydra to manage all experiment configurations from `config/run/*.yaml` files. Use `config_path="../config"` in all @hydra.main decorators
- COMPLETE DATA PIPELINE: Full data loading and preprocessing implementation. Use `.cache/` as the cache directory for all datasets and models (e.g., for HuggingFace, set `cache_dir=".cache/"`)
- WANDB REQUIRED: WandB is mandatory for metrics logging (except trial_mode validation)

## Hydra Configuration Structure
Each run config file (`config/run/{run_id}.yaml`) contains:
- run_id: Unique identifier for this run
- method: The method name (baseline, proposed, ablation, etc.)
- model: Model-specific parameters (name, architecture details, hyperparameters)
- dataset: Dataset-specific parameters (name, preprocessing settings, split ratios)
- training: Training hyperparameters (learning rate, batch size, epochs, optimizer settings, validation split)
- optuna: Hyperparameter search space definition for Optuna optimization

## Command Line Interface
The generated code must support the following CLI:

**Training (main.py):**
```bash
# Full experiment with WandB logging
uv run python -u -m src.main run={run_id} results_dir={path}

# Trial mode (validation only, WandB disabled)
uv run python -u -m src.main run={run_id} results_dir={path} trial_mode=true
```
- `run`: Experiment run_id (matching a run_id from config/run/*.yaml)
- `results_dir`: Output directory (passed from GitHub Actions workflow)
- `trial_mode=true` (optional): Lightweight execution for validation (epochs=1, batches limited to 1-2, disable Optuna n_trials=0, **WandB disabled**)

**Evaluation (evaluate.py, independent execution):**
```bash
uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'
```
- `results_dir`: Directory containing experiment metadata and where outputs will be saved
- `run_ids`: JSON string list of run IDs to evaluate (e.g., '["run-1-proposed-bert-glue", "run-2-baseline-bert-glue"]')
- Executed as a separate workflow after all training runs complete
- **NOT called from main.py**

## Script Structure (ExperimentCode format)
Generate complete code for these files ONLY. Do not create any additional files beyond this structure:

**`src/train.py`**: Single experiment run executor
- Uses Hydra config to load all parameters
- Called as subprocess by main.py
- Responsibilities:
  * Train model with given configuration
  * Initialize WandB: `wandb.init(entity=cfg.wandb.entity, project=cfg.wandb.project, id=cfg.run.run_id, config=OmegaConf.to_container(cfg, resolve=True), resume="allow")`
  * Skip `wandb.init()` if `cfg.wandb.mode == "disabled"` (trial_mode)
  * **Log ALL metrics to WandB comprehensively**:
    - Use `wandb.log()` at each training step/batch/epoch with ALL relevant metrics
    - Log as frequently as possible (per-batch or per-epoch) to capture training dynamics
  * **Save final/best metrics to WandB summary**:
    - Use `wandb.summary["key"] = value` for final results
  * Print WandB run URL to stdout
- **NO results.json, no stdout JSON output, no figure generation**

**`src/evaluate.py`**: Independent evaluation and visualization script
- **Execution**: Run independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
- **NOT called from main.py** - executes as separate workflow after all training completes
- **Responsibilities**:
  * Parse command line arguments:
    - `results_dir`: Output directory path
    - `run_ids`: JSON string list of run IDs (parse with `json.loads(args.run_ids)`)
  * Load WandB config from `{results_dir}/config.yaml`
  * **Retrieve comprehensive experimental data from WandB API** for specified run_ids:
    ```python
    import json
    api = wandb.Api()
    run_ids = json.loads(args.run_ids)  # Parse JSON string to list
    for run_id in run_ids:
        run = api.run(f"{entity}/{project}/{run_id}")
        history = run.history()  # pandas DataFrame with ALL time-series metrics (train_loss, val_acc, etc.)
        summary = run.summary._json_dict  # Final/best metrics (best_val_acc, final_test_acc, etc.)
        config = dict(run.config)  # Run configuration (hyperparameters, model settings, etc.)
    ```
  * **STEP 1: Per-Run Processing** (for each run_id):
    - Export **comprehensive** run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
    - Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
    - Each run should have its own subdirectory with its metrics and figures
  * **STEP 2: Aggregated Analysis** (after processing all runs):
    - Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
    - Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
    - Generate comparison figures to: `{results_dir}/comparison/`:
      * Cross-run comparison charts (bar charts, box plots)
      * Performance metrics tables
      * Statistical significance tests
  * **Figure Generation Guidelines**:
    - Use matplotlib or seaborn with proper legends, annotations, tight_layout
    - For line graphs: annotate significant values (final/best values)
    - For bar graphs: annotate values above each bar
    - Use GLOBALLY UNIQUE image filenames to prevent collisions across different runs and directories**:
      * Per-run figures: `{run_id}_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `run-1-proposed-bert-glue_learning_curve.pdf`)
      * Comparison figures: `comparison_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `comparison_accuracy_bar_chart.pdf`)
  * Print all generated file paths to stdout (both per-run and comparison)

**`src/preprocess.py`**: Complete preprocessing pipeline implementation for the specified datasets

**`src/model.py`**: Complete model architecture implementations for all methods (proposed and comparative methods)

**`src/main.py`**: Main orchestrator
- Receives run_id via Hydra, launches train.py as subprocess, manages logs
- **DOES NOT call evaluate.py** (evaluate.py runs independently in separate workflow)
- Use `@hydra.main(config_path="../config")` since execution is from repository root
- Pass all Hydra overrides to train.py subprocess (e.g., `wandb.mode=disabled`, `trial_mode=true`)
- In trial_mode, automatically set `wandb.mode=disabled`

**`config/config.yaml`**: Main Hydra configuration file
- MUST include WandB configuration:
  ```yaml
  wandb:
    entity: gengaru617-personal
    project: 251021-test
    mode: online  # Automatically set to "disabled" in trial_mode
  ```

**`pyproject.toml`**: Complete project dependencies
- MUST include: `hydra-core`, `wandb` (required)
- Include as needed: `optuna`, `torch`, `transformers`, `datasets`, etc.


## Key Implementation Focus Areas
1. **Hydra-Driven Configuration**: All parameters loaded from run configs dynamically
2. **Algorithm Core**: Full implementation of the proposed method with proper abstraction
3. **Trial Mode Behavior**: trial_mode=true automatically disables WandB (sets wandb.mode=disabled)
4. **Run Execution**: main.py executes a single run_id passed via CLI (GitHub Actions dispatches multiple runs separately)
5. **WandB Integration**: All metrics logged to WandB; train.py does NOT output JSON to stdout or save results.json
6. **Independent Evaluation**: evaluate.py runs separately, fetches data from WandB API, generates all figures



## Code Validation Feedback


**Previous Validation Issue**: Hydra configuration search path is wrong.  Both src/main.py and src/train.py declare
    @hydra.main(config_path="../config", config_name="config")
Hydra resolves config_path relative to the *current working directory* (which is the project root when the user runs `python -m src.main`, and an `outputs/**` directory when src/train is spawned from src.main).  The directory `../config` therefore points one level **above** the project root (or to `outputs/…/../config` for src.train) and Hydra cannot find any configuration files.

The correct path should be "config" (or the path should be constructed programmatically from `__file__`).  Until this is fixed neither `src.main` nor `src.train` can load `config/config.yaml` or any `config/run/*.yaml`, so the whole experiment pipeline fails at start-up.
**Action Required**: Address this issue in the implementation.

**Previous Code (for reference)**:
{"config_yaml": "defaults:\n  - _self_\n  - run: ???\n\nrun:\n  run_id: null\n\nresults_dir: ./results\ntrial_mode: false\n\nwandb:\n  entity: gengaru617-personal\n  project: 251021-test\n  mode: online  # overwritten to disabled in trial_mode\n\nmethod: \"\"\nalgorithm: {}\nmodel: {}\ndataset: {}\ntraining: {}\noptuna: {}", "evaluate_py": "import argparse\nimport json\nimport os\nfrom itertools import combinations\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml\nfrom scipy.stats import mannwhitneyu\n\n# --------------------------------------------------------------------------------------\n# Helper utilities\n# --------------------------------------------------------------------------------------\n\ndef ensure_dir(p: Path) -\u003e Path:\n    p.mkdir(parents=True, exist_ok=True)\n    return p\n\n\ndef plot_learning_curve(history_df: pd.DataFrame, run_id: str, out_path: Path) -\u003e None:\n    plt.figure(figsize=(6, 4))\n    x = history_df.get(\"cumulative_time\", history_df.index)\n    for col in [\"best_so_far\", \"val_acc\", \"epoch_train_acc\"]:\n        if col in history_df.columns:\n            plt.plot(x, history_df[col], label=col)\n    plt.xlabel(\"Cumulative Time (s)\" if \"cumulative_time\" in history_df.columns else \"Event Index\")\n    plt.ylabel(\"Accuracy\")\n    plt.title(f\"Learning Curves \u2013 {run_id}\")\n    plt.legend()\n    plt.tight_layout()\n    plt.savefig(out_path, format=\"pdf\")\n    plt.close()\n\n\ndef plot_confusion_matrix(cm: np.ndarray, run_id: str, out_path: Path) -\u003e None:\n    plt.figure(figsize=(6, 5))\n    sns.heatmap(cm, annot=True, fmt=\"d\", cmap=\"Blues\")\n    plt.xlabel(\"Predicted\")\n    plt.ylabel(\"True\")\n    plt.title(f\"Confusion Matrix \u2013 {run_id}\")\n    plt.tight_layout()\n    plt.savefig(out_path, format=\"pdf\")\n    plt.close()\n\n\ndef plot_box(df: pd.DataFrame, metric: str, out_path: Path) -\u003e None:\n    plt.figure(figsize=(6, 4))\n    sns.boxplot(x=\"method\", y=metric, data=df, palette=\"Set2\")\n    plt.ylabel(metric)\n    plt.title(f\"Distribution of {metric} per method\")\n    plt.tight_layout()\n    plt.savefig(out_path, format=\"pdf\")\n    plt.close()\n\n\ndef plot_improvement_bar(improv_dict: Dict[str, float], metric: str, out_path: Path) -\u003e None:\n    methods = list(improv_dict.keys())\n    values = [improv_dict[m] * 100 for m in methods]  # percent\n    plt.figure(figsize=(6, 4))\n    sns.barplot(x=methods, y=values, palette=\"Set3\")\n    plt.ylabel(f\"Improvement over baseline (%) \u2013 {metric}\")\n    for i, v in enumerate(values):\n        plt.text(i, v + 0.5, f\"{v:.2f}%\", ha=\"center\", va=\"bottom\", fontsize=7)\n    plt.tight_layout()\n    plt.savefig(out_path, format=\"pdf\")\n    plt.close()\n\n\n# --------------------------------------------------------------------------------------\n# Statistics \u0026 Aggregation helpers\n# --------------------------------------------------------------------------------------\n\ndef run_significance_tests(df: pd.DataFrame, out_dir: Path) -\u003e Path:\n    methods = df[\"method\"].unique().tolist()\n    metrics = [c for c in df.columns if c not in {\"run_id\", \"method\"}]\n    results: Dict[str, Dict[str, Dict[str, float]]] = {}\n    for m1, m2 in combinations(methods, 2):\n        key = f\"{m1}_vs_{m2}\"\n        results[key] = {}\n        g1, g2 = df[df[\"method\"] == m1], df[df[\"method\"] == m2]\n        for metric in metrics:\n            x, y = g1[metric].dropna().values, g2[metric].dropna().values\n            if len(x) == 0 or len(y) == 0:\n                statistic, p_val = float(\"nan\"), float(\"nan\")\n            else:\n                statistic, p_val = mannwhitneyu(x, y, alternative=\"two-sided\")\n            results[key][metric] = {\"statistic\": float(statistic), \"p_value\": float(p_val)}\n    out_path = ensure_dir(out_dir) / \"aggregated_significance_tests.json\"\n    with open(out_path, \"w\", encoding=\"utf-8\") as fp:\n        json.dump(results, fp, indent=2)\n    print(out_path)\n    return out_path\n\n\ndef compute_improvement_rates(df: pd.DataFrame, maximise_metrics: List[str]) -\u003e Dict[str, Dict[str, float]]:\n    \"\"\"Compute improvement rates of each method over baseline (first method in alphabetical order).\"\"\"\n    baseline_method = None\n    for name in [\"baseline\", \"comparative-1\", \"boil\", \"BOIL\"]:\n        if name in df[\"method\"].unique():\n            baseline_method = name\n            break\n    if baseline_method is None:\n        baseline_method = sorted(df[\"method\"].unique())[0]\n    baseline_values = df[df[\"method\"] == baseline_method]\n    improvs: Dict[str, Dict[str, float]] = {}\n    for method in df[\"method\"].unique():\n        if method == baseline_method:\n            continue\n        improvs[method] = {}\n        target_values = df[df[\"method\"] == method]\n        for metric in maximise_metrics:\n            base_mean = baseline_values[metric].mean()\n            tgt_mean = target_values[metric].mean()\n            if base_mean == 0:\n                rate = float(\"nan\")\n            else:\n                rate = (tgt_mean - base_mean) / base_mean\n            improvs[method][metric] = rate\n        # time_to_85 is minimisation metric\n        if \"time_to_85\" in df.columns:\n            base_mean = baseline_values[\"time_to_85\"].mean()\n            tgt_mean = target_values[\"time_to_85\"].mean()\n            rate = (base_mean - tgt_mean) / base_mean if base_mean != 0 else float(\"nan\")\n            improvs[method][\"time_to_85\"] = rate\n    return improvs\n\n\ndef aggregate_and_compare(all_results: Dict[str, Dict], out_dir: Path) -\u003e None:\n    records: List[Dict] = []\n    for run_id, data in all_results.items():\n        summary = data[\"summary\"]\n        config = data[\"config\"]\n        records.append({\n            \"run_id\": run_id,\n            \"method\": config.get(\"method\", \"unknown\"),\n            \"best_val_acc\": summary.get(\"final_best_val_acc\", np.nan),\n            \"auc\": summary.get(\"auc_accuracy\", np.nan),\n            \"time_to_85\": summary.get(\"time_to_85\", np.nan),\n        })\n\n    df = pd.DataFrame.from_records(records)\n    out_dir = ensure_dir(out_dir)\n    df.to_json(out_dir / \"aggregated_metrics.json\", orient=\"records\", indent=2)\n\n    # ------------------- box-plots for each metric -------------------\n    for metric in [\"best_val_acc\", \"auc\", \"time_to_85\"]:\n        if metric not in df.columns:\n            continue\n        box_path = out_dir / f\"comparison_{metric}_boxplot.pdf\"\n        plot_box(df, metric, box_path)\n        print(box_path)\n\n    # ------------------- improvement rates ---------------------------\n    maximize_metrics = [\"best_val_acc\", \"auc\"]\n    improv_rates = compute_improvement_rates(df, maximize_metrics)\n    improv_json = out_dir / \"aggregated_improvement_rates.json\"\n    with open(improv_json, \"w\", encoding=\"utf-8\") as fp:\n        json.dump(improv_rates, fp, indent=2)\n    print(improv_json)\n\n    # bar-charts for improvement rates\n    for metric in maximize_metrics + [\"time_to_85\"]:\n        bar_path = out_dir / f\"comparison_improvement_{metric}.pdf\"\n        # flatten dict for this metric\n        flat = {m: vals.get(metric, np.nan) for m, vals in improv_rates.items()}\n        if len(flat) == 0:\n            continue\n        plot_improvement_bar(flat, metric, bar_path)\n        print(bar_path)\n\n    # ------------------- simple mean bar for best acc ----------------\n    plt.figure(figsize=(8, 4))\n    sns.barplot(x=\"run_id\", y=\"best_val_acc\", hue=\"method\", data=df, dodge=False)\n    plt.xticks(rotation=45, ha=\"right\")\n    for i, v in enumerate(df[\"best_val_acc\"].values):\n        plt.text(i, v + 0.001, f\"{v:.3f}\", ha=\"center\", va=\"bottom\", fontsize=7)\n    plt.ylabel(\"Best Validation Accuracy\")\n    plt.tight_layout()\n    acc_bar = out_dir / \"comparison_best_accuracy_bar_chart.pdf\"\n    plt.savefig(acc_bar, format=\"pdf\")\n    plt.close()\n    print(acc_bar)\n\n    # ------------------- statistical tests ---------------------------\n    run_significance_tests(df, out_dir)\n\n\n# --------------------------------------------------------------------------------------\n# Main entry point\n# --------------------------------------------------------------------------------------\n\ndef main() -\u003e None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"results_dir\", type=str)\n    parser.add_argument(\"run_ids\", type=str, help=\"JSON string list of run IDs to evaluate\")\n    args = parser.parse_args()\n\n    results_dir = Path(args.results_dir).expanduser()\n    run_ids: List[str] = json.loads(args.run_ids)\n\n    with open(results_dir / \"config.yaml\", \"r\", encoding=\"utf-8\") as fp:\n        wandb_cfg = yaml.safe_load(fp)\n    entity, project = wandb_cfg.get(\"entity\"), wandb_cfg.get(\"project\")\n\n    api = wandb.Api()\n    all_results: Dict[str, Dict] = {}\n\n    for run_id in run_ids:\n        run_save_dir = ensure_dir(results_dir / run_id)\n        run = api.run(f\"{entity}/{project}/{run_id}\")\n        history = run.history()\n        summary = run.summary._json_dict\n        config = dict(run.config)\n\n        # ------------------- export history --------------------------\n        hist_path = run_save_dir / \"metrics.json\"\n        history.to_json(hist_path, orient=\"records\", indent=2)\n        print(hist_path)\n\n        # ------------------- figures --------------------------------\n        lc_path = run_save_dir / f\"{run_id}_learning_curve.pdf\"\n        plot_learning_curve(history, run_id, lc_path)\n        print(lc_path)\n\n        if \"confusion_matrix\" in summary:\n            cm_arr = np.asarray(summary[\"confusion_matrix\"])\n            cm_path = run_save_dir / f\"{run_id}_confusion_matrix.pdf\"\n            plot_confusion_matrix(cm_arr, run_id, cm_path)\n            print(cm_path)\n\n        all_results[run_id] = {\"history\": history, \"summary\": summary, \"config\": config}\n\n    aggregate_and_compare(all_results, results_dir / \"comparison\")\n\n\nif __name__ == \"__main__\":\n    main()", "main_py": "import subprocess\nimport sys\nfrom pathlib import Path\n\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg: DictConfig):\n    results_dir = Path(cfg.results_dir).expanduser()\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    # store WandB creds (once)\n    wandb_cfg_path = results_dir / \"config.yaml\"\n    if not wandb_cfg_path.exists():\n        with open(wandb_cfg_path, \"w\", encoding=\"utf-8\") as fp:\n            fp.write(OmegaConf.to_yaml(cfg.wandb))\n\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\", f\"run={cfg.run.run_id}\", f\"results_dir={cfg.results_dir}\"]\n    if cfg.trial_mode:\n        cmd.append(\"trial_mode=true\")\n        cmd.append(\"wandb.mode=disabled\")\n\n    print(\"[main] Executing:\", \" \".join(cmd), flush=True)\n    proc = subprocess.Popen(cmd)\n    proc.communicate()\n    if proc.returncode != 0:\n        raise SystemExit(proc.returncode)\n\n\nif __name__ == \"__main__\":\n    main()", "model_py": "import torch.nn as nn\n\n\nclass MultiLayerPerceptron(nn.Module):\n    \"\"\"2-hidden-layer MLP.\"\"\"\n\n    def __init__(self, input_dim: int, hidden_units: int, output_dim: int, activation: str = \"relu\") -\u003e None:\n        super().__init__()\n        if activation == \"relu\":\n            act = nn.ReLU()\n        elif activation == \"tanh\":\n            act = nn.Tanh()\n        else:\n            raise ValueError(\"Unsupported activation\")\n\n        self.net = nn.Sequential(\n            nn.Flatten(),\n            nn.Linear(input_dim, hidden_units),\n            act,\n            nn.Linear(hidden_units, hidden_units),\n            act,\n            nn.Linear(hidden_units, output_dim),\n        )\n\n    def forward(self, x):  # type: ignore\n        return self.net(x)", "preprocess_py": "from pathlib import Path\nfrom typing import Tuple\n\nimport torch\nfrom torch.utils.data import DataLoader, random_split\nfrom torchvision import datasets, transforms\n\nCACHE_DIR = Path(\".cache\").absolute()\n\n\ndef get_dataloaders(cfg) -\u003e Tuple[DataLoader, DataLoader, DataLoader]:\n    root = CACHE_DIR / cfg.dataset.name\n    root.mkdir(parents=True, exist_ok=True)\n\n    tfs = [transforms.ToTensor()]\n    if getattr(cfg.dataset, \"normalization\", True):\n        tfs.append(transforms.Normalize((0.5,), (0.5,)))\n    transform = transforms.Compose(tfs)\n\n    full_train = datasets.FashionMNIST(root=str(root), train=True, download=True, transform=transform)\n    test_set = datasets.FashionMNIST(root=str(root), train=False, download=True, transform=transform)\n\n    train_size = cfg.dataset.train_size\n    val_size = cfg.dataset.val_size\n\n    train_subset, val_subset = random_split(full_train, [train_size, val_size], generator=torch.Generator().manual_seed(42))\n\n    num_workers = 4 if torch.cuda.is_available() else 0\n    pin_mem = torch.cuda.is_available()\n\n    train_loader = DataLoader(train_subset, batch_size=cfg.training.batch_size, shuffle=True,\n                              num_workers=num_workers, pin_memory=pin_mem)\n    val_loader = DataLoader(val_subset, batch_size=cfg.training.batch_size, shuffle=False,\n                            num_workers=num_workers, pin_memory=pin_mem)\n    test_loader = DataLoader(test_set, batch_size=cfg.training.batch_size, shuffle=False,\n                             num_workers=num_workers, pin_memory=pin_mem)\n    return train_loader, val_loader, test_loader", "pyproject_toml": "[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n[tool.poetry]\nname = \"ca-boil-experiments\"\nversion = \"0.1.0\"\ndescription = \"Reproducible experiments for CA-BOIL vs BOIL on Fashion-MNIST\"\nauthors = [\"AI Researcher \u003cresearch@example.com\u003e\"]\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\ntorch = \"^2.1.0\"\ntorchvision = \"^0.16.0\"\nhydra-core = \"^1.3.2\"\nomegaconf = \"^2.3.0\"\nwandb = \"^0.16.0\"\noptuna = \"^3.4.0\"\nscikit-learn = \"^1.3.2\"\nscipy = \"^1.11.3\"\nnumpy = \"^1.26.2\"\npandas = \"^2.1.3\"\nmatplotlib = \"^3.8.0\"\nseaborn = \"^0.13.0\"\ntqdm = \"^4.66.1\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.3\"", "train_py": "import json\nimport os\nimport random\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple\n\nimport hydra\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom omegaconf import DictConfig, OmegaConf\nfrom scipy.stats import norm\nfrom sklearn.metrics import confusion_matrix\nimport wandb\n\nfrom src.model import MultiLayerPerceptron\nfrom src.preprocess import get_dataloaders\n\n# --------------------------------------------------------------------------------------\n# Utility helpers\n# --------------------------------------------------------------------------------------\n\ndef set_seed(seed: int = 42) -\u003e None:\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\ndef ensure_dir(path: Path) -\u003e Path:\n    path.mkdir(parents=True, exist_ok=True)\n    return path\n\n\n# --------------------------------------------------------------------------------------\n# Training of one hyper-parameter setting (inner objective)\n# --------------------------------------------------------------------------------------\n\ndef train_single_model(*,\n                       evaluation_index: int,\n                       lr: float,\n                       hidden_units: int,\n                       cfg: DictConfig,\n                       loaders: Tuple[torch.utils.data.DataLoader, torch.utils.data.DataLoader],\n                       device: torch.device) -\u003e Tuple[Dict, float]:\n    \"\"\"Train a 2-layer MLP and return metrics + wall-clock time.\"\"\"\n\n    start_time = time.perf_counter()\n\n    train_loader, val_loader = loaders\n    model = MultiLayerPerceptron(input_dim=cfg.model.input_dim,\n                                 hidden_units=hidden_units,\n                                 output_dim=cfg.model.output_dim,\n                                 activation=cfg.model.activation).to(device)\n\n    criterion = nn.CrossEntropyLoss()\n    optimizer = optim.Adam(model.parameters(), lr=lr, weight_decay=cfg.training.weight_decay)\n\n    best_val_acc: float = 0.0\n    cm_best: np.ndarray | None = None\n\n    global_step = 0\n    for epoch in range(cfg.training.epochs):\n        # ------------------------------- train ---------------------------------\n        model.train()\n        running_loss, running_correct, running_total = 0.0, 0, 0\n        for batch_idx, (inputs, targets) in enumerate(train_loader):\n            if cfg.trial_mode and batch_idx \u003e 1:\n                break  # Quick run in trial mode\n            inputs, targets = inputs.to(device), targets.to(device)\n            optimizer.zero_grad()\n            outputs = model(inputs)\n            loss = criterion(outputs, targets)\n            loss.backward()\n            nn.utils.clip_grad_norm_(model.parameters(), cfg.training.max_grad_norm)\n            optimizer.step()\n\n            running_loss += loss.item() * inputs.size(0)\n            preds = outputs.argmax(1)\n            running_correct += preds.eq(targets).sum().item()\n            running_total += targets.size(0)\n\n            if cfg.wandb.mode != \"disabled\":\n                wandb.log({\n                    \"train/loss\": loss.item(),\n                    \"epoch\": epoch,\n                    \"batch\": batch_idx,\n                    \"evaluation_index\": evaluation_index,\n                }, commit=False)\n            global_step += 1\n\n        epoch_train_loss = running_loss / running_total\n        epoch_train_acc = running_correct / running_total\n\n        # ----------------------------- validation ------------------------------\n        model.eval()\n        val_correct, val_total = 0, 0\n        all_true: List[int] = []\n        all_pred: List[int] = []\n        with torch.no_grad():\n            for batch_idx, (inputs, targets) in enumerate(val_loader):\n                if cfg.trial_mode and batch_idx \u003e 1:\n                    break\n                inputs, targets = inputs.to(device), targets.to(device)\n                outputs = model(inputs)\n                preds = outputs.argmax(1)\n                val_correct += preds.eq(targets).sum().item()\n                val_total += targets.size(0)\n                all_true.extend(targets.cpu().tolist())\n                all_pred.extend(preds.cpu().tolist())\n        val_acc = val_correct / val_total\n\n        if val_acc \u003e best_val_acc:\n            best_val_acc = val_acc\n            cm_best = confusion_matrix(all_true, all_pred, labels=list(range(cfg.model.output_dim)))\n            best_state_dict = model.state_dict()\n\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log({\n                \"train/epoch_loss\": epoch_train_loss,\n                \"train/epoch_acc\": epoch_train_acc,\n                \"val/acc\": val_acc,\n                \"evaluation_index\": evaluation_index,\n                \"epoch\": epoch,\n            }, commit=True)\n\n    runtime = time.perf_counter() - start_time\n\n    if cm_best is None:\n        cm_best = confusion_matrix(all_true, all_pred, labels=list(range(cfg.model.output_dim)))\n\n    metrics = {\n        \"best_val_accuracy\": best_val_acc,\n        \"confusion_matrix\": cm_best.tolist(),\n    }\n    return metrics, runtime\n\n\n# --------------------------------------------------------------------------------------\n# Helper maths\n# --------------------------------------------------------------------------------------\n\ndef expected_improvement(mu: np.ndarray, sigma: np.ndarray, y_best: float) -\u003e np.ndarray:\n    sigma = np.maximum(sigma, 1e-9)\n    z = (mu - y_best) / sigma\n    ei = (mu - y_best) * norm.cdf(z) + sigma * norm.pdf(z)\n    return ei\n\n\ndef auc(xs: np.ndarray, ys: np.ndarray) -\u003e float:\n    return np.trapz(ys, xs)\n\n\ndef first_time(ys: List[float], ts: List[float], thresh: float = 0.85) -\u003e float:\n    for y, t in zip(ys, ts):\n        if y \u003e= thresh:\n            return t\n    return float(\"inf\")\n\n\n# --------------------------------------------------------------------------------------\n# BOIL optimiser\n# --------------------------------------------------------------------------------------\n\ndef run_boil(cfg: DictConfig, loaders, device):\n    from sklearn.gaussian_process import GaussianProcessRegressor\n    from sklearn.gaussian_process.kernels import Matern, WhiteKernel\n    from sklearn.linear_model import LinearRegression\n\n    bounds = np.array([\n        [np.log10(cfg.optuna.search_space.learning_rate.low), np.log10(cfg.optuna.search_space.learning_rate.high)],\n        [cfg.optuna.search_space.hidden_units.low, cfg.optuna.search_space.hidden_units.high],\n    ])\n\n    def sample(n: int) -\u003e np.ndarray:\n        lr = 10 ** np.random.uniform(bounds[0, 0], bounds[0, 1], n)\n        hu = np.random.randint(bounds[1, 0], bounds[1, 1] + 1, n)\n        return np.stack([lr, hu], 1)\n\n    n_init = cfg.algorithm.n_init_points\n    total_evals = 1 if cfg.trial_mode else cfg.algorithm.total_evaluations\n\n    X, y_u, y_c = [], [], []\n    cum_t, cum_ts = 0.0, []\n    best_so_far = 0.0\n\n    gp_u = GaussianProcessRegressor(kernel=Matern() + WhiteKernel(1e-5))\n    cost_lin = LinearRegression()\n\n    for ei in range(total_evals):\n        if ei \u003c n_init or len(X) \u003c 2:\n            x_next = sample(1)[0]\n        else:\n            gp_u.fit(np.array(X), np.array(y_u))\n            cost_lin.fit(np.array(X), np.array(y_c))\n            cand = sample(4000)\n            mu_u, sigma_u = gp_u.predict(cand, return_std=True)\n            mu_c = cost_lin.predict(cand)\n            acq = np.log(expected_improvement(mu_u, sigma_u, max(y_u)) + 1e-12) - np.log(mu_c + 1e-12)\n            x_next = cand[np.argmax(acq)]\n\n        lr, hu = float(x_next[0]), int(round(x_next[1]))\n        metrics, wall = train_single_model(evaluation_index=ei, lr=lr, hidden_units=hu,\n                                           cfg=cfg, loaders=loaders, device=device)\n        val_acc = metrics[\"best_val_accuracy\"]\n\n        cum_t += wall\n        cum_ts.append(cum_t)\n        X.append(x_next)\n        y_u.append(val_acc)\n        y_c.append(np.log(wall))\n        best_so_far = max(best_so_far, val_acc)\n\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log({\n                \"evaluation\": ei,\n                \"lr\": lr,\n                \"hidden_units\": hu,\n                \"val_acc\": val_acc,\n                \"best_so_far\": best_so_far,\n                \"cumulative_time\": cum_t,\n                \"wall_clock\": wall,\n            })\n\n    if cfg.wandb.mode != \"disabled\":\n        wandb.summary[\"final_best_val_acc\"] = best_so_far\n        wandb.summary[\"auc_accuracy\"] = auc(np.arange(len(y_u)), np.asarray(y_u))\n        wandb.summary[\"time_to_85\"] = first_time(y_u, cum_ts, 0.85)\n        wandb.summary[\"confusion_matrix\"] = metrics[\"confusion_matrix\"]\n\n\n# --------------------------------------------------------------------------------------\n# CA-BOIL optimiser\n# --------------------------------------------------------------------------------------\n\ndef run_ca_boil(cfg: DictConfig, loaders, device):\n    from sklearn.gaussian_process import GaussianProcessRegressor\n    from sklearn.gaussian_process.kernels import Matern, WhiteKernel\n\n    bounds = np.array([\n        [np.log10(cfg.optuna.search_space.learning_rate.low), np.log10(cfg.optuna.search_space.learning_rate.high)],\n        [cfg.optuna.search_space.hidden_units.low, cfg.optuna.search_space.hidden_units.high],\n    ])\n\n    def sample(n: int) -\u003e np.ndarray:\n        lr = 10 ** np.random.uniform(bounds[0, 0], bounds[0, 1], n)\n        hu = np.random.randint(bounds[1, 0], bounds[1, 1] + 1, n)\n        return np.stack([lr, hu], 1)\n\n    n_init = cfg.algorithm.n_init_points\n    total_evals = 1 if cfg.trial_mode else cfg.algorithm.total_evaluations\n    kappa = cfg.algorithm.acquisition.kappa\n\n    X, y_u, y_c = [], [], []\n    cum_t, cum_ts = 0.0, []\n    best_so_far = 0.0\n\n    gp_u = GaussianProcessRegressor(kernel=Matern() + WhiteKernel(1e-5))\n    gp_c = GaussianProcessRegressor(kernel=Matern() + WhiteKernel(1e-5))\n\n    for ei in range(total_evals):\n        if ei \u003c n_init or len(X) \u003c 3:\n            x_next = sample(1)[0]\n        else:\n            gp_u.fit(np.array(X), np.array(y_u))\n            gp_c.fit(np.array(X), np.array(y_c))\n            cand = sample(4000)\n            mu_u, sigma_u = gp_u.predict(cand, return_std=True)\n            mu_c, sigma_c = gp_c.predict(cand, return_std=True)\n            ei_vals = expected_improvement(mu_u, sigma_u, max(y_u))\n            acq = ei_vals / (mu_c + kappa * sigma_c + 1e-12)\n            x_next = cand[np.argmax(acq)]\n\n        lr, hu = float(x_next[0]), int(round(x_next[1]))\n        metrics, wall = train_single_model(evaluation_index=ei, lr=lr, hidden_units=hu,\n                                           cfg=cfg, loaders=loaders, device=device)\n        val_acc = metrics[\"best_val_accuracy\"]\n\n        cum_t += wall\n        cum_ts.append(cum_t)\n        X.append(x_next)\n        y_u.append(val_acc)\n        y_c.append(np.log(wall))\n        best_so_far = max(best_so_far, val_acc)\n\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log({\n                \"evaluation\": ei,\n                \"lr\": lr,\n                \"hidden_units\": hu,\n                \"val_acc\": val_acc,\n                \"best_so_far\": best_so_far,\n                \"cumulative_time\": cum_t,\n                \"wall_clock\": wall,\n            })\n\n    if cfg.wandb.mode != \"disabled\":\n        wandb.summary[\"final_best_val_acc\"] = best_so_far\n        wandb.summary[\"auc_accuracy\"] = auc(np.arange(len(y_u)), np.asarray(y_u))\n        wandb.summary[\"time_to_85\"] = first_time(y_u, cum_ts, 0.85)\n        wandb.summary[\"confusion_matrix\"] = metrics[\"confusion_matrix\"]\n\n\n# --------------------------------------------------------------------------------------\n# Main entry-point (single run)\n# --------------------------------------------------------------------------------------\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg: DictConfig):\n    # ------------------------- trial-mode tweaks -------------------------\n    if cfg.trial_mode:\n        cfg.wandb.mode = \"disabled\"\n        cfg.training.epochs = 1\n        cfg.algorithm.total_evaluations = 1\n        cfg.optuna.n_trials = 0\n\n    results_root = ensure_dir(Path(cfg.results_dir).expanduser())\n    run_dir = ensure_dir(results_root / cfg.run.run_id)\n    set_seed(42)\n\n    # ------------------------- WandB initialisation ----------------------\n    if cfg.wandb.mode != \"disabled\":\n        wandb.init(entity=cfg.wandb.entity,\n                   project=cfg.wandb.project,\n                   id=cfg.run.run_id,\n                   resume=\"allow\",\n                   mode=cfg.wandb.mode,\n                   dir=str(run_dir),\n                   config=OmegaConf.to_container(cfg, resolve=True))\n        print(\"WandB URL:\", wandb.run.get_url(), flush=True)\n    else:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n\n    # ------------------------------ data ---------------------------------\n    device = torch.device(\"cuda\" if torch.cuda.is_available() and cfg.training.device == \"cuda\" else \"cpu\")\n    train_loader, val_loader, _ = get_dataloaders(cfg)\n\n    # ------------------------ launch optimiser --------------------------\n    if cfg.algorithm.name.lower() == \"boil\":\n        run_boil(cfg, (train_loader, val_loader), device)\n    elif cfg.algorithm.name.lower() in {\"ca-boil\", \"ca_boil\", \"caboil\"}:\n        run_ca_boil(cfg, (train_loader, val_loader), device)\n    else:\n        raise ValueError(f\"Unsupported algorithm {cfg.algorithm.name}\")\n\n    # ----------------- persist WandB creds for evaluator ----------------\n    cred_path = results_root / \"config.yaml\"\n    if not cred_path.exists():\n        with open(cred_path, \"w\", encoding=\"utf-8\") as fp:\n            fp.write(OmegaConf.to_yaml(cfg.wandb))\n\n    # ------------------------------ finish -------------------------------\n    if cfg.wandb.mode != \"disabled\":\n        wandb.finish()\n\n\nif __name__ == \"__main__\":\n    main()"}

Fix the issues identified above while preserving the correct parts of the implementation.



# Experimental Environment
NVIDIA A100×8
VRAM：80GB×8
RAM：2048 GB

# Current Research Method
{
    "Open Problems": "1. BOIL estimates the wall-clock cost of evaluating a hyper-parameter setting with a plain LinearRegression model.  In practice the relation (e.g. GPU time, number of simulator steps) is highly non-linear and heteroscedastic.\n2. The acquisition function divides the expected utility by the point estimate of the cost, ignoring its uncertainty; when the cost model is wrong the optimiser can select apparently cheap but actually expensive configurations, wasting budget.\n3. Both shortcomings can be fixed with a very small change – replacing the linear cost surrogate with a probabilistic model and letting the acquisition treat cost uncertainty explicitly.",
    "Methods": "Method name: CA-BOIL (Cost-Aware BOIL)\nMinimal changes to BOIL:\n1. Replace the LinearRegression cost model with a second Gaussian-Process surrogate GP_c(x,t) that yields mean µ_c and standard deviation σ_c of the (log) cost.\n2. Redefine the acquisition used in utility_cost_evaluation from\n        U_old =  log(EI) – log(µ_c)\n   to the cost-uncertainty–aware\n        U_new =  EI /( µ_c + κ · σ_c )\n   (equivalently  log(EI) – log(µ_c+κσ_c) in BOIL’s code).  κ≥0 is a single scalar (default κ=1).\nTheoretical intuition:\n• GP_c gives a calibrated posterior over cost.  Dividing by µ_c+κσ_c is the familiar concept of \"expected improvement per (risk-adjusted) cost\"; high uncertainty on cost is penalised so the optimiser prefers configurations that are both promising and reliably cheap.\n• The change keeps BOIL’s product-kernel GP for utility, the learning-curve compression, the data-augmentation, etc. completely intact – only 25 lines of code are touched.",
    "Experimental Setup": "Goal: show that CA-BOIL reaches the same test accuracy with less wall-clock time than vanilla BOIL.\nTask: tune (learning-rate, hidden-units) of an MLP on the Fashion-MNIST dataset for 10 epochs.\nTrue cost: measured GPU time per evaluation (simulated here as  0.4·hidden_units + 1200·learning_rate^2  + noise).\nProtocol:\n1. Use the public BOIL implementation as the baseline (n_init_points=3, budget 40 evaluations).\n2. Implement CA-BOIL by adding GP_c and U_new (κ=1).\n3. Run each optimiser 20 times with different random seeds.\nMetrics:\n• Best validation accuracy reached vs. cumulative true time (area under curve).\n• Total time to reach 85% accuracy.",
    "Experimental Code": "import numpy as np, time, torch, sklearn\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import Matern, WhiteKernel\n\n# === tiny wrapper around the user objective =================================\n\ndef objective(cfg):\n    lr, h = cfg  # learning-rate, hidden units\n    start = time.time()\n    # --- train a very small network for 10 epochs (placeholder) ------------\n    acc = 1.0 - (lr*3 + (200-h)/400) + np.random.randn()*0.01  # fake accuracy\n    true_cost = 0.4*h + 1200*lr**2 + np.random.rand()*3        # fake time\n    return acc, np.log(true_cost), time.time()-start\n\n# === cost-aware acquisition =================================================\n\ndef expected_improvement(mu, sigma, y_best):\n    from scipy.stats import norm\n    z = (mu - y_best)/sigma\n    return (mu - y_best)*norm.cdf(z) + sigma*norm.pdf(z)\n\ndef acquisition(X, gp_u, gp_c, y_best, kappa):\n    mu_u, sigma_u = gp_u.predict(X, return_std=True)\n    mu_c, sigma_c = gp_c.predict(X, return_std=True)\n    ei = expected_improvement(mu_u, sigma_u, y_best)\n    return ei / (mu_c + kappa*sigma_c)\n\n# === minimal CA-BOIL optimisation loop (no virtual obs for brevity) =========\n\nbounds = np.array([[1e-4, 1e-1],   # learning rate\n                   [ 50 , 400 ]])  # hidden units\n\ngp_u = GaussianProcessRegressor(Matern()+WhiteKernel(1e-5))\ngp_c = GaussianProcessRegressor(Matern()+WhiteKernel(1e-5))\n\nX, y_u, y_c = [], [], []\n# initial design\nfor _ in range(3):\n    x = np.random.uniform(bounds[:,0], bounds[:,1])\n    acc, cost_log, _ = objective(x)\n    X.append(x)\n    y_u.append(acc)\n    y_c.append(cost_log)\n\nfor it in range(37):  # total 40\n    gp_u.fit(np.array(X), np.array(y_u))\n    gp_c.fit(np.array(X), np.array(y_c))\n\n    y_best = np.max(y_u)\n    # optimise acquisition by random search (sufficient for demo)\n    cand = np.random.uniform(bounds[:,0], bounds[:,1], size=(5000,2))\n    acq_values = acquisition(cand, gp_u, gp_c, y_best, kappa=1.0)\n    x_next = cand[np.argmax(acq_values)]\n\n    acc, cost_log, _ = objective(x_next)\n    X.append(x_next)\n    y_u.append(acc)\n    y_c.append(cost_log)\n\nprint('best val acc', np.max(y_u))\n",
    "Expected Result": "Across 20 independent runs CA-BOIL reduces the median wall-clock time to reach 85% accuracy by ≈20-30% compared with BOIL, and achieves slightly higher final accuracy for the same fixed time budget because it avoids a few very costly evaluations that BOIL selects due to under-estimated cost.",
    "Expected Conclusion": "By swapping the linear cost surrogate for a simple GP and dividing the improvement by a risk-adjusted cost estimate, CA-BOIL becomes less prone to costly mistakes while keeping BOIL’s strengths (learning-curve compression and data augmentation).  The single added κ hyper-parameter and ~25 lines of code yield a consistent speed-up, demonstrating that even very small, principled modifications can translate into tangible efficiency gains in hyper-parameter optimisation."
}

# Experimental Design
- Summary: We benchmark the new Cost-Aware BOIL (CA-BOIL) hyper-parameter optimiser against the original BOIL on a medium-size neural-network tuning task.  The optimiser must find the learning-rate (10⁻⁴–10⁻¹) and hidden-layer width (50–400 units) that maximise validation accuracy of a 2-layer MLP after ten training epochs on Fashion-MNIST while paying the true wall-clock cost of each trial (measured GPU time).  
Workflow
1. Dataset loading: Fashion-MNIST train/validation split.
2. Model definition: a fixed 2-layer MLP (≈0.1 M parameters) implemented in PyTorch.
3. Objective function: (cfg) ↦ (validation-accuracy, log(cost)).  Cost is obtained through torch.cuda.Event timers.
4. Optimisers:
   • BOIL baseline: single GP for utility, linear regression for cost, acquisition U_old = log(EI) – log(µ_c).
   • Proposed CA-BOIL: identical utility GP but replaces the linear cost model with a GP GP_c and uses acquisition U_new = EI / (µ_c + κ σ_c) (κ = 1).
5. Loop: 3 Sobol initial points + 37 adaptive steps (budget 40).  Both methods are repeated for 20 random seeds on the same machine (8 × A100, 80 GB each).
6. Logging: after every evaluation we record cumulative wall-clock time, best validation accuracy, chosen hyper-parameters, and acquisition value.
7. Post-processing: compute per-run curves best-acc(t), integrate AUC, and measure the time when 85 % validation accuracy is first reached.
8. Statistical analysis: report median and 95 %-CI across seeds, and perform two-sided Wilcoxon signed-rank tests on each metric.
The experiment demonstrates that CA-BOIL reaches 85 % accuracy ≈25 % faster and avoids extreme outliers in time consumption, validating that modelling cost uncertainty yields more budget-robust optimisation.
- Evaluation metrics: ['Area Under Best-Accuracy–Time Curve', 'Time To 85% Accuracy', 'Final Best Validation Accuracy']

# Experiment Runs

- Run ID: proposed-2-Layer-MLP-0.1M-parameters--Fashion-MNIST
  Method: proposed
  Model: 2-Layer MLP (≈0.1M parameters)
  Dataset: Fashion-MNIST
  Config File: config/run/proposed-2-Layer-MLP-0.1M-parameters--Fashion-MNIST.yaml
  
  Config Content:
  ```yaml
  run_id: proposed-2-Layer-MLP-0.1M-parameters--Fashion-MNIST
method: proposed
algorithm:
  name: CA-BOIL
  n_init_points: 3         # Sobol seed evaluations
  total_evaluations: 40    # 3 initial + 37 BO steps
  cost_model:
    type: gp
    kernel: matern_plus_white
  acquisition:
    type: ei_over_risk_adjusted_cost
    kappa: 1.0             # default; can be tuned by Optuna
    formula: "EI / (mu_c + kappa * sigma_c)"
model:
  name: 2-layer-mlp
  input_dim: 784           # 28×28 images flattened
  hidden_units: 200        # placeholder, will be overridden by Optuna suggestion
  activation: relu
  output_dim: 10
  parameter_budget: "≈0.1M"
dataset:
  name: fashion_mnist
  root: ./data
  train_size: 50000        # 83 % of full train split
  val_size: 10000          # 17 % of full train split
  normalization: true
training:
  epochs: 10               # fixed according to protocol
  batch_size: 128
  optimizer: adam
  weight_decay: 0.0
  max_grad_norm: 1.0
  device: cuda
logging:
  use_wandb: true
  project: ca-boil
  log_interval: 1          # log after each evaluation
resources:
  gpus_per_trial: 1
  gpu_type: A100
  cpus_per_trial: 4
  memory_gb: 16
optuna:
  n_trials: 50
  direction: maximize
  sampler: tpe
  pruner: median
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-1
    hidden_units:
      type: int
      low: 50
      high: 400
      step: 1
    kappa:
      type: uniform
      low: 0.5
      high: 2.0

  ```
  

- Run ID: comparative-1-2-Layer-MLP-0.1M-parameters--Fashion-MNIST
  Method: comparative-1
  Model: 2-Layer MLP (≈0.1M parameters)
  Dataset: Fashion-MNIST
  Config File: config/run/comparative-1-2-Layer-MLP-0.1M-parameters--Fashion-MNIST.yaml
  
  Config Content:
  ```yaml
  run_id: comparative-1-2-Layer-MLP-0.1M-parameters--Fashion-MNIST
method: comparative-1
algorithm:
  name: BOIL
  n_init_points: 3
  total_evaluations: 40
  cost_model:
    type: linear           # original BOIL uses plain LinearRegression
  acquisition:
    type: log_ei_minus_log_cost
    formula: "log(EI) - log(mu_c)"
model:
  name: 2-layer-mlp
  input_dim: 784
  hidden_units: 200        # placeholder, tuned by Optuna
  activation: relu
  output_dim: 10
  parameter_budget: "≈0.1M"
dataset:
  name: fashion_mnist
  root: ./data
  train_size: 50000
  val_size: 10000
  normalization: true
training:
  epochs: 10
  batch_size: 128
  optimizer: adam
  weight_decay: 0.0
  max_grad_norm: 1.0
  device: cuda
logging:
  use_wandb: true
  project: boil-baseline
  log_interval: 1
resources:
  gpus_per_trial: 1
  gpu_type: A100
  cpus_per_trial: 4
  memory_gb: 16
optuna:
  n_trials: 50
  direction: maximize
  sampler: tpe
  pruner: median
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-1
    hidden_units:
      type: int
      low: 50
      high: 400
      step: 1

  ```
  


# External Resources (Use these for implementation)

**HuggingFace Models:**


**HuggingFace Datasets:**

- ID: zalando-datasets/fashion_mnist




Generate complete, production-ready experiment code that integrates with Hydra configuration system.
Output:
{
    "train_py": "import json\nimport os\nimport random\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple\n\nimport hydra\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom omegaconf import DictConfig, OmegaConf\nfrom scipy.stats import norm\nfrom sklearn.metrics import confusion_matrix\nimport wandb\n\nfrom src.model import MultiLayerPerceptron\nfrom src.preprocess import get_dataloaders\n\n# -----------------------------------------------------------------------------\n# Global constant – absolute path to the configuration directory\n# -----------------------------------------------------------------------------\nCONFIG_PATH = str((Path(__file__).resolve().parent.parent / \"config\").absolute())\n\n# -----------------------------------------------------------------------------\n# Utility helpers\n# -----------------------------------------------------------------------------\n\ndef set_seed(seed: int = 42) -> None:\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\ndef ensure_dir(path: Path) -> Path:\n    path.mkdir(parents=True, exist_ok=True)\n    return path\n\n# -----------------------------------------------------------------------------\n# Training of one hyper-parameter setting (inner objective)\n# -----------------------------------------------------------------------------\n\ndef train_single_model(*,\n                       evaluation_index: int,\n                       lr: float,\n                       hidden_units: int,\n                       cfg: DictConfig,\n                       loaders: Tuple[torch.utils.data.DataLoader, torch.utils.data.DataLoader],\n                       device: torch.device) -> Tuple[Dict, float]:\n    \"\"\"Train a 2-layer MLP and return metrics & wall-clock time.\"\"\"\n\n    start_time = time.perf_counter()\n\n    train_loader, val_loader = loaders\n    model = MultiLayerPerceptron(input_dim=cfg.model.input_dim,\n                                 hidden_units=hidden_units,\n                                 output_dim=cfg.model.output_dim,\n                                 activation=cfg.model.activation).to(device)\n\n    criterion = nn.CrossEntropyLoss()\n    optimizer = optim.Adam(model.parameters(), lr=lr, weight_decay=cfg.training.weight_decay)\n\n    best_val_acc: float = 0.0\n    cm_best: np.ndarray | None = None\n\n    global_step = 0\n    for epoch in range(cfg.training.epochs):\n        # -------------------------- training loop --------------------------\n        model.train()\n        running_loss, running_correct, running_total = 0.0, 0, 0\n        for batch_idx, (inputs, targets) in enumerate(train_loader):\n            if cfg.trial_mode and batch_idx > 1:\n                break  # quick pass in trial_mode\n            inputs, targets = inputs.to(device), targets.to(device)\n            optimizer.zero_grad()\n            outputs = model(inputs)\n            loss = criterion(outputs, targets)\n            loss.backward()\n            nn.utils.clip_grad_norm_(model.parameters(), cfg.training.max_grad_norm)\n            optimizer.step()\n\n            running_loss += loss.item() * inputs.size(0)\n            preds = outputs.argmax(1)\n            running_correct += preds.eq(targets).sum().item()\n            running_total += targets.size(0)\n\n            if cfg.wandb.mode != \"disabled\":\n                wandb.log({\n                    \"train/loss\": loss.item(),\n                    \"epoch\": epoch,\n                    \"batch\": batch_idx,\n                    \"evaluation_index\": evaluation_index,\n                }, commit=False)\n            global_step += 1\n\n        epoch_train_loss = running_loss / running_total\n        epoch_train_acc = running_correct / running_total\n\n        # ---------------------------- validation ---------------------------\n        model.eval()\n        val_correct, val_total = 0, 0\n        all_true: List[int] = []\n        all_pred: List[int] = []\n        with torch.no_grad():\n            for batch_idx, (inputs, targets) in enumerate(val_loader):\n                if cfg.trial_mode and batch_idx > 1:\n                    break\n                inputs, targets = inputs.to(device), targets.to(device)\n                outputs = model(inputs)\n                preds = outputs.argmax(1)\n                val_correct += preds.eq(targets).sum().item()\n                val_total += targets.size(0)\n                all_true.extend(targets.cpu().tolist())\n                all_pred.extend(preds.cpu().tolist())\n        val_acc = val_correct / val_total\n\n        if val_acc > best_val_acc:\n            best_val_acc = val_acc\n            cm_best = confusion_matrix(all_true, all_pred, labels=list(range(cfg.model.output_dim)))\n\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log({\n                \"train/epoch_loss\": epoch_train_loss,\n                \"train/epoch_acc\": epoch_train_acc,\n                \"val/acc\": val_acc,\n                \"evaluation_index\": evaluation_index,\n                \"epoch\": epoch,\n            }, commit=True)\n\n    runtime = time.perf_counter() - start_time\n\n    if cm_best is None:\n        cm_best = confusion_matrix(all_true, all_pred, labels=list(range(cfg.model.output_dim)))\n\n    metrics = {\n        \"best_val_accuracy\": best_val_acc,\n        \"confusion_matrix\": cm_best.tolist(),\n    }\n    return metrics, runtime\n\n# -----------------------------------------------------------------------------\n# Math helpers\n# -----------------------------------------------------------------------------\n\ndef expected_improvement(mu: np.ndarray, sigma: np.ndarray, y_best: float) -> np.ndarray:\n    sigma = np.maximum(sigma, 1e-9)\n    z = (mu - y_best) / sigma\n    ei = (mu - y_best) * norm.cdf(z) + sigma * norm.pdf(z)\n    return ei\n\n\ndef auc(xs: np.ndarray, ys: np.ndarray) -> float:\n    \"\"\"Trapezoidal AUC.\"\"\"\n    return np.trapz(ys, xs)\n\n\ndef first_time(ys: List[float], ts: List[float], thresh: float = 0.85) -> float:\n    \"\"\"First timestamp where y >= thresh, `inf` if never reached.\"\"\"\n    for y, t in zip(ys, ts):\n        if y >= thresh:\n            return t\n    return float(\"inf\")\n\n# -----------------------------------------------------------------------------\n# BOIL optimiser (baseline)\n# -----------------------------------------------------------------------------\n\ndef run_boil(cfg: DictConfig, loaders, device):\n    from sklearn.gaussian_process import GaussianProcessRegressor\n    from sklearn.gaussian_process.kernels import Matern, WhiteKernel\n    from sklearn.linear_model import LinearRegression\n\n    bounds = np.array([\n        [np.log10(cfg.optuna.search_space.learning_rate.low), np.log10(cfg.optuna.search_space.learning_rate.high)],\n        [cfg.optuna.search_space.hidden_units.low, cfg.optuna.search_space.hidden_units.high],\n    ])\n\n    def sample(n: int) -> np.ndarray:\n        lr = 10 ** np.random.uniform(bounds[0, 0], bounds[0, 1], n)\n        hu = np.random.randint(bounds[1, 0], bounds[1, 1] + 1, n)\n        return np.stack([lr, hu], 1)\n\n    n_init = cfg.algorithm.n_init_points\n    total_evals = 1 if cfg.trial_mode else cfg.algorithm.total_evaluations\n\n    X, y_u, y_c = [], [], []\n    cum_t, cum_ts = 0.0, []\n    best_so_far = 0.0\n\n    gp_u = GaussianProcessRegressor(kernel=Matern() + WhiteKernel(1e-5))\n    cost_lin = LinearRegression()\n\n    for ei in range(total_evals):\n        if ei < n_init or len(X) < 2:\n            x_next = sample(1)[0]\n        else:\n            gp_u.fit(np.array(X), np.array(y_u))\n            cost_lin.fit(np.array(X), np.array(y_c))\n            cand = sample(4000)\n            mu_u, sigma_u = gp_u.predict(cand, return_std=True)\n            mu_c = cost_lin.predict(cand)\n            acq = np.log(expected_improvement(mu_u, sigma_u, max(y_u)) + 1e-12) - np.log(mu_c + 1e-12)\n            x_next = cand[np.argmax(acq)]\n\n        lr, hu = float(x_next[0]), int(round(x_next[1]))\n        metrics, wall = train_single_model(evaluation_index=ei, lr=lr, hidden_units=hu,\n                                           cfg=cfg, loaders=loaders, device=device)\n        val_acc = metrics[\"best_val_accuracy\"]\n\n        cum_t += wall\n        cum_ts.append(cum_t)\n        X.append(x_next)\n        y_u.append(val_acc)\n        y_c.append(np.log(wall))\n        best_so_far = max(best_so_far, val_acc)\n\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log({\n                \"evaluation\": ei,\n                \"lr\": lr,\n                \"hidden_units\": hu,\n                \"val_acc\": val_acc,\n                \"best_so_far\": best_so_far,\n                \"cumulative_time\": cum_t,\n                \"wall_clock\": wall,\n            })\n\n    if cfg.wandb.mode != \"disabled\":\n        wandb.summary[\"final_best_val_acc\"] = best_so_far\n        wandb.summary[\"auc_accuracy\"] = auc(np.arange(len(y_u)), np.asarray(y_u))\n        wandb.summary[\"time_to_85\"] = first_time(y_u, cum_ts, 0.85)\n        wandb.summary[\"confusion_matrix\"] = metrics[\"confusion_matrix\"]\n\n# -----------------------------------------------------------------------------\n# CA-BOIL optimiser (proposed)\n# -----------------------------------------------------------------------------\n\ndef run_ca_boil(cfg: DictConfig, loaders, device):\n    from sklearn.gaussian_process import GaussianProcessRegressor\n    from sklearn.gaussian_process.kernels import Matern, WhiteKernel\n\n    bounds = np.array([\n        [np.log10(cfg.optuna.search_space.learning_rate.low), np.log10(cfg.optuna.search_space.learning_rate.high)],\n        [cfg.optuna.search_space.hidden_units.low, cfg.optuna.search_space.hidden_units.high],\n    ])\n\n    def sample(n: int) -> np.ndarray:\n        lr = 10 ** np.random.uniform(bounds[0, 0], bounds[0, 1], n)\n        hu = np.random.randint(bounds[1, 0], bounds[1, 1] + 1, n)\n        return np.stack([lr, hu], 1)\n\n    n_init = cfg.algorithm.n_init_points\n    total_evals = 1 if cfg.trial_mode else cfg.algorithm.total_evaluations\n    kappa = cfg.algorithm.acquisition.kappa\n\n    X, y_u, y_c = [], [], []\n    cum_t, cum_ts = 0.0, []\n    best_so_far = 0.0\n\n    gp_u = GaussianProcessRegressor(kernel=Matern() + WhiteKernel(1e-5))\n    gp_c = GaussianProcessRegressor(kernel=Matern() + WhiteKernel(1e-5))\n\n    for ei in range(total_evals):\n        if ei < n_init or len(X) < 3:\n            x_next = sample(1)[0]\n        else:\n            gp_u.fit(np.array(X), np.array(y_u))\n            gp_c.fit(np.array(X), np.array(y_c))\n            cand = sample(4000)\n            mu_u, sigma_u = gp_u.predict(cand, return_std=True)\n            mu_c, sigma_c = gp_c.predict(cand, return_std=True)\n            ei_vals = expected_improvement(mu_u, sigma_u, max(y_u))\n            acq = ei_vals / (mu_c + kappa * sigma_c + 1e-12)\n            x_next = cand[np.argmax(acq)]\n\n        lr, hu = float(x_next[0]), int(round(x_next[1]))\n        metrics, wall = train_single_model(evaluation_index=ei, lr=lr, hidden_units=hu,\n                                           cfg=cfg, loaders=loaders, device=device)\n        val_acc = metrics[\"best_val_accuracy\"]\n\n        cum_t += wall\n        cum_ts.append(cum_t)\n        X.append(x_next)\n        y_u.append(val_acc)\n        y_c.append(np.log(wall))\n        best_so_far = max(best_so_far, val_acc)\n\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log({\n                \"evaluation\": ei,\n                \"lr\": lr,\n                \"hidden_units\": hu,\n                \"val_acc\": val_acc,\n                \"best_so_far\": best_so_far,\n                \"cumulative_time\": cum_t,\n                \"wall_clock\": wall,\n            })\n\n    if cfg.wandb.mode != \"disabled\":\n        wandb.summary[\"final_best_val_acc\"] = best_so_far\n        wandb.summary[\"auc_accuracy\"] = auc(np.arange(len(y_u)), np.asarray(y_u))\n        wandb.summary[\"time_to_85\"] = first_time(y_u, cum_ts, 0.85)\n        wandb.summary[\"confusion_matrix\"] = metrics[\"confusion_matrix\"]\n\n# -----------------------------------------------------------------------------\n# Main entry-point for a single experiment run\n# -----------------------------------------------------------------------------\n\n@hydra.main(version_base=None, config_path=CONFIG_PATH, config_name=\"config\")\ndef main(cfg: DictConfig):\n    # ------------------------- trial-mode tweaks -------------------------\n    if cfg.trial_mode:\n        cfg.wandb.mode = \"disabled\"\n        cfg.training.epochs = 1\n        cfg.algorithm.total_evaluations = 1\n        cfg.optuna.n_trials = 0\n\n    results_root = ensure_dir(Path(cfg.results_dir).expanduser())\n    run_dir = ensure_dir(results_root / cfg.run.run_id)\n    set_seed(42)\n\n    # --------------------- WandB initialisation -------------------------\n    if cfg.wandb.mode != \"disabled\":\n        wandb.init(entity=cfg.wandb.entity,\n                   project=cfg.wandb.project,\n                   id=cfg.run.run_id,\n                   resume=\"allow\",\n                   mode=cfg.wandb.mode,\n                   dir=str(run_dir),\n                   config=OmegaConf.to_container(cfg, resolve=True))\n        print(\"WandB URL:\", wandb.run.get_url(), flush=True)\n    else:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n\n    # --------------------------- data ------------------------------\n    device = torch.device(\"cuda\" if torch.cuda.is_available() and cfg.training.device == \"cuda\" else \"cpu\")\n    train_loader, val_loader, _ = get_dataloaders(cfg)\n\n    # --------------------- launch optimiser ------------------------\n    algo_name = cfg.algorithm.name.lower()\n    if algo_name == \"boil\":\n        run_boil(cfg, (train_loader, val_loader), device)\n    elif algo_name in {\"ca-boil\", \"caboil\", \"ca_boil\"}:\n        run_ca_boil(cfg, (train_loader, val_loader), device)\n    else:\n        raise ValueError(f\"Unsupported algorithm {cfg.algorithm.name}\")\n\n    # ------------- persist WandB creds for evaluator --------------\n    cred_path = results_root / \"config.yaml\"\n    if not cred_path.exists():\n        with open(cred_path, \"w\", encoding=\"utf-8\") as fp:\n            fp.write(OmegaConf.to_yaml(cfg.wandb))\n\n    # --------------------------- finish ---------------------------\n    if cfg.wandb.mode != \"disabled\":\n        wandb.finish()\n\n\nif __name__ == \"__main__\":\n    main()",
    "evaluate_py": "import argparse\nimport json\nimport os\nfrom itertools import combinations\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml\nfrom scipy.stats import mannwhitneyu\n\n# --------------------------------------------------------------------------------------\n# Helper utilities\n# --------------------------------------------------------------------------------------\n\ndef ensure_dir(p: Path) -> Path:\n    p.mkdir(parents=True, exist_ok=True)\n    return p\n\n\ndef plot_learning_curve(history_df: pd.DataFrame, run_id: str, out_path: Path) -> None:\n    plt.figure(figsize=(6, 4))\n    x = history_df.get(\"cumulative_time\", history_df.index)\n    for col in [\"best_so_far\", \"val_acc\", \"epoch_train_acc\"]:\n        if col in history_df.columns:\n            plt.plot(x, history_df[col], label=col)\n    plt.xlabel(\"Cumulative Time (s)\" if \"cumulative_time\" in history_df.columns else \"Event Index\")\n    plt.ylabel(\"Accuracy\")\n    plt.title(f\"Learning Curves – {run_id}\")\n    plt.legend()\n    plt.tight_layout()\n    plt.savefig(out_path, format=\"pdf\")\n    plt.close()\n\n\ndef plot_confusion_matrix(cm: np.ndarray, run_id: str, out_path: Path) -> None:\n    plt.figure(figsize=(6, 5))\n    sns.heatmap(cm, annot=True, fmt=\"d\", cmap=\"Blues\")\n    plt.xlabel(\"Predicted\")\n    plt.ylabel(\"True\")\n    plt.title(f\"Confusion Matrix – {run_id}\")\n    plt.tight_layout()\n    plt.savefig(out_path, format=\"pdf\")\n    plt.close()\n\n\ndef plot_box(df: pd.DataFrame, metric: str, out_path: Path) -> None:\n    plt.figure(figsize=(6, 4))\n    sns.boxplot(x=\"method\", y=metric, data=df, palette=\"Set2\")\n    plt.ylabel(metric)\n    plt.title(f\"Distribution of {metric} per method\")\n    plt.tight_layout()\n    plt.savefig(out_path, format=\"pdf\")\n    plt.close()\n\n\ndef plot_improvement_bar(improv_dict: Dict[str, float], metric: str, out_path: Path) -> None:\n    methods = list(improv_dict.keys())\n    values = [improv_dict[m] * 100 for m in methods]  # percent\n    plt.figure(figsize=(6, 4))\n    sns.barplot(x=methods, y=values, palette=\"Set3\")\n    plt.ylabel(f\"Improvement over baseline (%) – {metric}\")\n    for i, v in enumerate(values):\n        plt.text(i, v + 0.5, f\"{v:.2f}%\", ha=\"center\", va=\"bottom\", fontsize=7)\n    plt.tight_layout()\n    plt.savefig(out_path, format=\"pdf\")\n    plt.close()\n\n\n# --------------------------------------------------------------------------------------\n# Statistics & Aggregation helpers\n# --------------------------------------------------------------------------------------\n\ndef run_significance_tests(df: pd.DataFrame, out_dir: Path) -> Path:\n    methods = df[\"method\"].unique().tolist()\n    metrics = [c for c in df.columns if c not in {\"run_id\", \"method\"}]\n    results: Dict[str, Dict[str, Dict[str, float]]] = {}\n    for m1, m2 in combinations(methods, 2):\n        key = f\"{m1}_vs_{m2}\"\n        results[key] = {}\n        g1, g2 = df[df[\"method\"] == m1], df[df[\"method\"] == m2]\n        for metric in metrics:\n            x, y = g1[metric].dropna().values, g2[metric].dropna().values\n            if len(x) == 0 or len(y) == 0:\n                statistic, p_val = float(\"nan\"), float(\"nan\")\n            else:\n                statistic, p_val = mannwhitneyu(x, y, alternative=\"two-sided\")\n            results[key][metric] = {\"statistic\": float(statistic), \"p_value\": float(p_val)}\n    out_path = ensure_dir(out_dir) / \"aggregated_significance_tests.json\"\n    with open(out_path, \"w\", encoding=\"utf-8\") as fp:\n        json.dump(results, fp, indent=2)\n    print(out_path)\n    return out_path\n\n\ndef compute_improvement_rates(df: pd.DataFrame, maximise_metrics: List[str]) -> Dict[str, Dict[str, float]]:\n    \"\"\"Compute improvement rates of each method over baseline (first method in alphabetical order).\"\"\"\n    baseline_method = None\n    for name in [\"baseline\", \"comparative-1\", \"boil\", \"BOIL\"]:\n        if name in df[\"method\"].unique():\n            baseline_method = name\n            break\n    if baseline_method is None:\n        baseline_method = sorted(df[\"method\"].unique())[0]\n    baseline_values = df[df[\"method\"] == baseline_method]\n    improvs: Dict[str, Dict[str, float]] = {}\n    for method in df[\"method\"].unique():\n        if method == baseline_method:\n            continue\n        improvs[method] = {}\n        target_values = df[df[\"method\"] == method]\n        for metric in maximise_metrics:\n            base_mean = baseline_values[metric].mean()\n            tgt_mean = target_values[metric].mean()\n            if base_mean == 0:\n                rate = float(\"nan\")\n            else:\n                rate = (tgt_mean - base_mean) / base_mean\n            improvs[method][metric] = rate\n        # time_to_85 is a minimisation metric\n        if \"time_to_85\" in df.columns:\n            base_mean = baseline_values[\"time_to_85\"].mean()\n            tgt_mean = target_values[\"time_to_85\"].mean()\n            rate = (base_mean - tgt_mean) / base_mean if base_mean != 0 else float(\"nan\")\n            improvs[method][\"time_to_85\"] = rate\n    return improvs\n\n\ndef aggregate_and_compare(all_results: Dict[str, Dict], out_dir: Path) -> None:\n    records: List[Dict] = []\n    for run_id, data in all_results.items():\n        summary = data[\"summary\"]\n        config = data[\"config\"]\n        records.append({\n            \"run_id\": run_id,\n            \"method\": config.get(\"method\", \"unknown\"),\n            \"best_val_acc\": summary.get(\"final_best_val_acc\", np.nan),\n            \"auc\": summary.get(\"auc_accuracy\", np.nan),\n            \"time_to_85\": summary.get(\"time_to_85\", np.nan),\n        })\n\n    df = pd.DataFrame.from_records(records)\n    out_dir = ensure_dir(out_dir)\n    df.to_json(out_dir / \"aggregated_metrics.json\", orient=\"records\", indent=2)\n\n    # ------------------- box-plots for each metric -------------------\n    for metric in [\"best_val_acc\", \"auc\", \"time_to_85\"]:\n        if metric not in df.columns:\n            continue\n        box_path = out_dir / f\"comparison_{metric}_boxplot.pdf\"\n        plot_box(df, metric, box_path)\n        print(box_path)\n\n    # ------------------- improvement rates ---------------------------\n    maximize_metrics = [\"best_val_acc\", \"auc\"]\n    improv_rates = compute_improvement_rates(df, maximize_metrics)\n    improv_json = out_dir / \"aggregated_improvement_rates.json\"\n    with open(improv_json, \"w\", encoding=\"utf-8\") as fp:\n        json.dump(improv_rates, fp, indent=2)\n    print(improv_json)\n\n    for metric in maximize_metrics + [\"time_to_85\"]:\n        bar_path = out_dir / f\"comparison_improvement_{metric}.pdf\"\n        flat = {m: vals.get(metric, np.nan) for m, vals in improv_rates.items()}\n        if len(flat) == 0:\n            continue\n        plot_improvement_bar(flat, metric, bar_path)\n        print(bar_path)\n\n    # ------------------- simple mean bar for best acc ----------------\n    plt.figure(figsize=(8, 4))\n    sns.barplot(x=\"run_id\", y=\"best_val_acc\", hue=\"method\", data=df, dodge=False)\n    plt.xticks(rotation=45, ha=\"right\")\n    for i, v in enumerate(df[\"best_val_acc\"].values):\n        plt.text(i, v + 0.001, f\"{v:.3f}\", ha=\"center\", va=\"bottom\", fontsize=7)\n    plt.ylabel(\"Best Validation Accuracy\")\n    plt.tight_layout()\n    acc_bar = out_dir / \"comparison_best_accuracy_bar_chart.pdf\"\n    plt.savefig(acc_bar, format=\"pdf\")\n    plt.close()\n    print(acc_bar)\n\n    # ------------------- statistical tests ---------------------------\n    run_significance_tests(df, out_dir)\n\n\n# --------------------------------------------------------------------------------------\n# Main entry point\n# --------------------------------------------------------------------------------------\n\ndef main() -> None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"results_dir\", type=str)\n    parser.add_argument(\"run_ids\", type=str, help=\"JSON string list of run IDs to evaluate\")\n    args = parser.parse_args()\n\n    results_dir = Path(args.results_dir).expanduser()\n    run_ids: List[str] = json.loads(args.run_ids)\n\n    with open(results_dir / \"config.yaml\", \"r\", encoding=\"utf-8\") as fp:\n        wandb_cfg = yaml.safe_load(fp)\n    entity, project = wandb_cfg.get(\"entity\"), wandb_cfg.get(\"project\")\n\n    api = wandb.Api()\n    all_results: Dict[str, Dict] = {}\n\n    for run_id in run_ids:\n        run_save_dir = ensure_dir(results_dir / run_id)\n        run = api.run(f\"{entity}/{project}/{run_id}\")\n        history = run.history()\n        summary = run.summary._json_dict\n        config = dict(run.config)\n\n        # ------------------- export history --------------------------\n        hist_path = run_save_dir / \"metrics.json\"\n        history.to_json(hist_path, orient=\"records\", indent=2)\n        print(hist_path)\n\n        # ------------------- figures --------------------------------\n        lc_path = run_save_dir / f\"{run_id}_learning_curve.pdf\"\n        plot_learning_curve(history, run_id, lc_path)\n        print(lc_path)\n\n        if \"confusion_matrix\" in summary:\n            cm_arr = np.asarray(summary[\"confusion_matrix\"])\n            cm_path = run_save_dir / f\"{run_id}_confusion_matrix.pdf\"\n            plot_confusion_matrix(cm_arr, run_id, cm_path)\n            print(cm_path)\n\n        all_results[run_id] = {\"history\": history, \"summary\": summary, \"config\": config}\n\n    aggregate_and_compare(all_results, results_dir / \"comparison\")\n\n\nif __name__ == \"__main__\":\n    main()",
    "preprocess_py": "from pathlib import Path\nfrom typing import Tuple\n\nimport torch\nfrom torch.utils.data import DataLoader, random_split\nfrom torchvision import datasets, transforms\n\nCACHE_DIR = Path(\".cache\").absolute()\n\n\ndef get_dataloaders(cfg) -> Tuple[DataLoader, DataLoader, DataLoader]:\n    \"\"\"Return train, val, test loaders according to cfg.\"\"\"\n    root = CACHE_DIR / cfg.dataset.name\n    root.mkdir(parents=True, exist_ok=True)\n\n    tfs = [transforms.ToTensor()]\n    if getattr(cfg.dataset, \"normalization\", True):\n        # Fashion-MNIST normalisation constants\n        tfs.append(transforms.Normalize((0.5,), (0.5,)))\n    transform = transforms.Compose(tfs)\n\n    full_train = datasets.FashionMNIST(root=str(root), train=True, download=True, transform=transform)\n    test_set = datasets.FashionMNIST(root=str(root), train=False, download=True, transform=transform)\n\n    train_size = cfg.dataset.train_size\n    val_size = cfg.dataset.val_size\n\n    train_subset, val_subset = random_split(full_train, [train_size, val_size], generator=torch.Generator().manual_seed(42))\n\n    num_workers = 4 if torch.cuda.is_available() else 0\n    pin_mem = torch.cuda.is_available()\n\n    train_loader = DataLoader(train_subset, batch_size=cfg.training.batch_size, shuffle=True,\n                              num_workers=num_workers, pin_memory=pin_mem)\n    val_loader = DataLoader(val_subset, batch_size=cfg.training.batch_size, shuffle=False,\n                            num_workers=num_workers, pin_memory=pin_mem)\n    test_loader = DataLoader(test_set, batch_size=cfg.training.batch_size, shuffle=False,\n                             num_workers=num_workers, pin_memory=pin_mem)\n    return train_loader, val_loader, test_loader",
    "model_py": "import torch.nn as nn\n\n\nclass MultiLayerPerceptron(nn.Module):\n    \"\"\"Two-hidden-layer MLP suitable for Fashion-MNIST.\"\"\"\n\n    def __init__(self, input_dim: int, hidden_units: int, output_dim: int, activation: str = \"relu\") -> None:\n        super().__init__()\n        if activation == \"relu\":\n            act = nn.ReLU()\n        elif activation == \"tanh\":\n            act = nn.Tanh()\n        else:\n            raise ValueError(\"Unsupported activation\")\n\n        self.net = nn.Sequential(\n            nn.Flatten(),\n            nn.Linear(input_dim, hidden_units),\n            act,\n            nn.Linear(hidden_units, hidden_units),\n            act,\n            nn.Linear(hidden_units, output_dim),\n        )\n\n    def forward(self, x):  # type: ignore\n        return self.net(x)",
    "main_py": "import subprocess\nimport sys\nfrom pathlib import Path\n\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\n\n# -----------------------------------------------------------------------------\n# Absolute path to configuration directory (one level up from this file)\n# -----------------------------------------------------------------------------\nfrom pathlib import Path as _P\nCONFIG_PATH = str((_P(__file__).resolve().parent.parent / \"config\").absolute())\n\n\n@hydra.main(version_base=None, config_path=CONFIG_PATH, config_name=\"config\")\ndef main(cfg: DictConfig):\n    results_dir = Path(cfg.results_dir).expanduser()\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    # persist WandB credentials (once per results_dir)\n    wandb_cfg_path = results_dir / \"config.yaml\"\n    if not wandb_cfg_path.exists():\n        with open(wandb_cfg_path, \"w\", encoding=\"utf-8\") as fp:\n            fp.write(OmegaConf.to_yaml(cfg.wandb))\n\n    # build command for the actual training script\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\", f\"run={cfg.run.run_id}\", f\"results_dir={cfg.results_dir}\"]\n    if cfg.trial_mode:\n        cmd.append(\"trial_mode=true\")\n        cmd.append(\"wandb.mode=disabled\")\n\n    print(\"[main] Executing:\", \" \".join(cmd), flush=True)\n    proc = subprocess.Popen(cmd)\n    proc.communicate()\n    if proc.returncode != 0:\n        raise SystemExit(proc.returncode)\n\n\nif __name__ == \"__main__\":\n    main()",
    "pyproject_toml": "[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n[tool.poetry]\nname = \"ca-boil-experiments\"\nversion = \"0.1.0\"\ndescription = \"Reproducible experiments for CA-BOIL vs BOIL on Fashion-MNIST\"\nauthors = [\"AI Researcher <research@example.com>\"]\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\ntorch = \"^2.1.0\"\ntorchvision = \"^0.16.0\"\nhydra-core = \"^1.3.2\"\nomegaconf = \"^2.3.0\"\nwandb = \"^0.16.0\"\noptuna = \"^3.4.0\"\nscikit-learn = \"^1.3.2\"\nscipy = \"^1.11.3\"\nnumpy = \"^1.26.2\"\npandas = \"^2.1.3\"\nmatplotlib = \"^3.8.0\"\nseaborn = \"^0.13.0\"\ntqdm = \"^4.66.1\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.3\"",
    "config_yaml": "defaults:\n  - _self_\n  - run: ???\n\nrun:\n  run_id: null\n\nresults_dir: ./results\ntrial_mode: false\n\nwandb:\n  entity: gengaru617-personal\n  project: 251021-test\n  mode: online  # overwritten to disabled in trial_mode\n\nmethod: \"\"\nalgorithm: {}\nmodel: {}\ndataset: {}\ntraining: {}\noptuna: {}"
}
