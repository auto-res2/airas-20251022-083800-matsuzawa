
LLM Name: o3-2025-04-16
Input:
You are an AI code reviewer validating production-ready experiment code for research papers.

Analyze the provided experiment code and determine if it meets all requirements for immediate execution in research experiments.

# Instructions

## Core Validation Criteria
Check if the generated experiment code meets ALL of the following requirements:

1. **Complete Implementation**:
   - Every component is fully functional, production-ready, publication-worthy code
   - No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
   - All functions and classes are completely implemented
   - No truncated code sections or incomplete implementations

2. **Hydra Integration**:
   - Uses Hydra to manage all experiment configurations from `config/run/*.yaml` files
   - All parameters are loaded from run configs dynamically
   - Proper configuration structure with run_id, method, model, dataset, training, and optuna sections
   - CLI interface matches:
     * Training: `uv run python -u -m src.main run={run_id} results_dir={path}`
     * Evaluation: `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'` (independent execution)
   - Supports trial_mode=true flag for lightweight validation runs (automatically disables WandB)

3. **Complete Data Pipeline**:
   - Full data loading and preprocessing implementation
   - Dataset-specific preprocessing is properly implemented
   - No placeholder dataset loading code
   - Proper error handling for data operations
   - Uses `.cache/` as the cache directory for all datasets and models

4. **Model Implementation**:
   - Complete model architectures for all methods (proposed and comparative methods)
   - No placeholders (TODO, PLACEHOLDER, pass, or incomplete implementations)
   - When External Resources specify HuggingFace models: properly use and customize them (acceptable to wrap AutoModel, add adapters, etc.)
   - When no external models specified: implement architectures from scratch using PyTorch primitives
   - Model-specific configurations correctly applied
   - Proper PyTorch usage throughout

5. **File Structure Compliance**:
   - Contains EXACTLY these required files (and NO other files):
     * `src/train.py`
     * `src/evaluate.py`
     * `src/preprocess.py`
     * `src/model.py`
     * `src/main.py`
     * `pyproject.toml`
     * `config/config.yaml`
   - NO additional files (e.g., NO `src/__init__.py`, NO `setup.py`, NO other Python files)
   - No missing files from the structure
   - All functionality contained within specified files

6. **WandB Integration**:
   - train.py initializes WandB and logs ALL metrics comprehensively:
     * Use `wandb.log()` at each training step/batch/epoch with ALL relevant time-series metrics
     * Log as frequently as possible (per-batch or per-epoch) to capture complete training dynamics
     * Use `wandb.summary["key"] = value` to save final/best metrics (best_val_acc, final_test_acc, best_epoch, etc.)
   - trial_mode automatically disables WandB (sets wandb.mode=disabled)
   - NO results.json or stdout JSON dumps in train.py
   - config/config.yaml contains mandatory WandB settings (entity/project)

7. **Configuration Files**:
   - The generated code properly references config files via Hydra
   - NOTE: config/run/{run_id}.yaml files are provided separately (not in ExperimentCode)
   - All run configurations match the experiment_runs provided
   - Optuna search spaces are properly defined if applicable

8. **Evaluation Script Independence**:
   - evaluate.py is executed independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
   - Accepts `run_ids` parameter as JSON string list (parse with `json.loads(args.run_ids)`)
   - main.py DOES NOT call evaluate.py
   - evaluate.py retrieves comprehensive data from WandB API:
     * Use `wandb.Api()` to get run data: `run = api.run(f"{entity}/{project}/{run_id}")`
     * Retrieve: `history = run.history()`, `summary = run.summary._json_dict`, `config = dict(run.config)`
   - **STEP 1: Per-Run Processing** (for each run_id):
     * Export comprehensive run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
     * Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
     * Each run should have its own subdirectory with its metrics and figures
   - **STEP 2: Aggregated Analysis** (after processing all runs):
     * Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
     * Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
     * Generate comparison figures to: `{results_dir}/comparison/`
     * Cross-run comparison charts (bar charts, box plots)
     * Performance metrics tables
     * Statistical significance tests
   - Proper figure quality: legends, annotations, tight_layout
   - Follows GLOBALLY UNIQUE naming convention to prevent collisions:
     * Per-run figures: `{run_id}_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `run-1-proposed-bert-glue_learning_curve.pdf`)
     * Comparison figures: `comparison_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `comparison_accuracy_bar_chart.pdf`)
   - train.py and main.py generate NO figures
   - evaluate.py cannot run in trial_mode (no WandB data available when WandB disabled)

9. **Trial Mode Implementation**:
   - trial_mode=true flag properly reduces computational load
   - Training: epochs=1, batches limited to 1-2, Optuna disabled (n_trials=0), small evaluation subset
   - WandB automatically disabled in trial_mode (wandb.mode=disabled)
   - Purpose: Fast validation that code runs without errors

## Output Format
Respond with a JSON object containing:
- `is_code_ready`: boolean - true if ALL criteria are met, false otherwise
- `code_issue`: string - specific issues found if any criteria are not met, focusing on what needs to be fixed

# Current Research Method
{
    "Open Problems": "1. BOIL estimates the wall-clock cost of evaluating a hyper-parameter setting with a plain LinearRegression model.  In practice the relation (e.g. GPU time, number of simulator steps) is highly non-linear and heteroscedastic.\n2. The acquisition function divides the expected utility by the point estimate of the cost, ignoring its uncertainty; when the cost model is wrong the optimiser can select apparently cheap but actually expensive configurations, wasting budget.\n3. Both shortcomings can be fixed with a very small change – replacing the linear cost surrogate with a probabilistic model and letting the acquisition treat cost uncertainty explicitly.",
    "Methods": "Method name: CA-BOIL (Cost-Aware BOIL)\nMinimal changes to BOIL:\n1. Replace the LinearRegression cost model with a second Gaussian-Process surrogate GP_c(x,t) that yields mean µ_c and standard deviation σ_c of the (log) cost.\n2. Redefine the acquisition used in utility_cost_evaluation from\n        U_old =  log(EI) – log(µ_c)\n   to the cost-uncertainty–aware\n        U_new =  EI /( µ_c + κ · σ_c )\n   (equivalently  log(EI) – log(µ_c+κσ_c) in BOIL’s code).  κ≥0 is a single scalar (default κ=1).\nTheoretical intuition:\n• GP_c gives a calibrated posterior over cost.  Dividing by µ_c+κσ_c is the familiar concept of \"expected improvement per (risk-adjusted) cost\"; high uncertainty on cost is penalised so the optimiser prefers configurations that are both promising and reliably cheap.\n• The change keeps BOIL’s product-kernel GP for utility, the learning-curve compression, the data-augmentation, etc. completely intact – only 25 lines of code are touched.",
    "Experimental Setup": "Goal: show that CA-BOIL reaches the same test accuracy with less wall-clock time than vanilla BOIL.\nTask: tune (learning-rate, hidden-units) of an MLP on the Fashion-MNIST dataset for 10 epochs.\nTrue cost: measured GPU time per evaluation (simulated here as  0.4·hidden_units + 1200·learning_rate^2  + noise).\nProtocol:\n1. Use the public BOIL implementation as the baseline (n_init_points=3, budget 40 evaluations).\n2. Implement CA-BOIL by adding GP_c and U_new (κ=1).\n3. Run each optimiser 20 times with different random seeds.\nMetrics:\n• Best validation accuracy reached vs. cumulative true time (area under curve).\n• Total time to reach 85% accuracy.",
    "Experimental Code": "import numpy as np, time, torch, sklearn\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import Matern, WhiteKernel\n\n# === tiny wrapper around the user objective =================================\n\ndef objective(cfg):\n    lr, h = cfg  # learning-rate, hidden units\n    start = time.time()\n    # --- train a very small network for 10 epochs (placeholder) ------------\n    acc = 1.0 - (lr*3 + (200-h)/400) + np.random.randn()*0.01  # fake accuracy\n    true_cost = 0.4*h + 1200*lr**2 + np.random.rand()*3        # fake time\n    return acc, np.log(true_cost), time.time()-start\n\n# === cost-aware acquisition =================================================\n\ndef expected_improvement(mu, sigma, y_best):\n    from scipy.stats import norm\n    z = (mu - y_best)/sigma\n    return (mu - y_best)*norm.cdf(z) + sigma*norm.pdf(z)\n\ndef acquisition(X, gp_u, gp_c, y_best, kappa):\n    mu_u, sigma_u = gp_u.predict(X, return_std=True)\n    mu_c, sigma_c = gp_c.predict(X, return_std=True)\n    ei = expected_improvement(mu_u, sigma_u, y_best)\n    return ei / (mu_c + kappa*sigma_c)\n\n# === minimal CA-BOIL optimisation loop (no virtual obs for brevity) =========\n\nbounds = np.array([[1e-4, 1e-1],   # learning rate\n                   [ 50 , 400 ]])  # hidden units\n\ngp_u = GaussianProcessRegressor(Matern()+WhiteKernel(1e-5))\ngp_c = GaussianProcessRegressor(Matern()+WhiteKernel(1e-5))\n\nX, y_u, y_c = [], [], []\n# initial design\nfor _ in range(3):\n    x = np.random.uniform(bounds[:,0], bounds[:,1])\n    acc, cost_log, _ = objective(x)\n    X.append(x)\n    y_u.append(acc)\n    y_c.append(cost_log)\n\nfor it in range(37):  # total 40\n    gp_u.fit(np.array(X), np.array(y_u))\n    gp_c.fit(np.array(X), np.array(y_c))\n\n    y_best = np.max(y_u)\n    # optimise acquisition by random search (sufficient for demo)\n    cand = np.random.uniform(bounds[:,0], bounds[:,1], size=(5000,2))\n    acq_values = acquisition(cand, gp_u, gp_c, y_best, kappa=1.0)\n    x_next = cand[np.argmax(acq_values)]\n\n    acc, cost_log, _ = objective(x_next)\n    X.append(x_next)\n    y_u.append(acc)\n    y_c.append(cost_log)\n\nprint('best val acc', np.max(y_u))\n",
    "Expected Result": "Across 20 independent runs CA-BOIL reduces the median wall-clock time to reach 85% accuracy by ≈20-30% compared with BOIL, and achieves slightly higher final accuracy for the same fixed time budget because it avoids a few very costly evaluations that BOIL selects due to under-estimated cost.",
    "Expected Conclusion": "By swapping the linear cost surrogate for a simple GP and dividing the improvement by a risk-adjusted cost estimate, CA-BOIL becomes less prone to costly mistakes while keeping BOIL’s strengths (learning-curve compression and data augmentation).  The single added κ hyper-parameter and ~25 lines of code yield a consistent speed-up, demonstrating that even very small, principled modifications can translate into tangible efficiency gains in hyper-parameter optimisation."
}

# Experimental Design
- Strategy: We benchmark the new Cost-Aware BOIL (CA-BOIL) hyper-parameter optimiser against the original BOIL on a medium-size neural-network tuning task.  The optimiser must find the learning-rate (10⁻⁴–10⁻¹) and hidden-layer width (50–400 units) that maximise validation accuracy of a 2-layer MLP after ten training epochs on Fashion-MNIST while paying the true wall-clock cost of each trial (measured GPU time).  
Workflow
1. Dataset loading: Fashion-MNIST train/validation split.
2. Model definition: a fixed 2-layer MLP (≈0.1 M parameters) implemented in PyTorch.
3. Objective function: (cfg) ↦ (validation-accuracy, log(cost)).  Cost is obtained through torch.cuda.Event timers.
4. Optimisers:
   • BOIL baseline: single GP for utility, linear regression for cost, acquisition U_old = log(EI) – log(µ_c).
   • Proposed CA-BOIL: identical utility GP but replaces the linear cost model with a GP GP_c and uses acquisition U_new = EI / (µ_c + κ σ_c) (κ = 1).
5. Loop: 3 Sobol initial points + 37 adaptive steps (budget 40).  Both methods are repeated for 20 random seeds on the same machine (8 × A100, 80 GB each).
6. Logging: after every evaluation we record cumulative wall-clock time, best validation accuracy, chosen hyper-parameters, and acquisition value.
7. Post-processing: compute per-run curves best-acc(t), integrate AUC, and measure the time when 85 % validation accuracy is first reached.
8. Statistical analysis: report median and 95 %-CI across seeds, and perform two-sided Wilcoxon signed-rank tests on each metric.
The experiment demonstrates that CA-BOIL reaches 85 % accuracy ≈25 % faster and avoids extreme outliers in time consumption, validating that modelling cost uncertainty yields more budget-robust optimisation.
- Proposed Method: Cost-Aware BOIL (CA-BOIL)
Objective: accelerate Bayesian Optimisation with Inequality Learning (BOIL) by taking uncertainty in evaluation cost into account.
Key ideas:
1. Probabilistic cost surrogate: replace BOIL’s linear regression on observed (log) costs with a Gaussian-Process surrogate GP_c(x,t) with Matern + white kernels.  The GP yields a posterior mean µ_c(x) and standard deviation σ_c(x).
2. Risk-adjusted acquisition: for a candidate configuration x the utility acquisition is defined as
      U_new(x) = EI(x) / ( µ_c(x) + κ σ_c(x) ),
   where EI is the standard Expected Improvement of the utility GP and κ≥0 (default 1) controls cost-risk aversion.
3. Implementation: only ~25 lines change in the open-source BOIL codebase—add a second GP object, train it on the same design points’ logged costs, and swap one line in utility_cost_evaluation to compute U_new.
4. Algorithmic steps per BO iteration:
   a. Fit GP_u on (x, validation_accuracy).
   b. Fit GP_c on (x, log(cost)).
   c. Maximise U_new(x) over the search space via Thompson sampling + local L-BFGS.
   d. Evaluate the objective at x*, append the new data, repeat until budget.
Theoretically, dividing EI by a risk-adjusted denominator is equivalent to optimising expected improvement per unit of cost under a mean-variance formulation, so candidates with high cost uncertainty are automatically down-weighted.  The method preserves every other aspect of BOIL (learning-curve compression, virtual observations, product kernels) and introduces only one additional scalar hyper-parameter κ.
- Evaluation Metrics: ['Area Under Best-Accuracy–Time Curve', 'Time To 85% Accuracy', 'Final Best Validation Accuracy']

# Experiment Runs

- Run ID: proposed-2-Layer-MLP-0.1M-parameters--Fashion-MNIST
  Method: proposed
  Model: 2-Layer MLP (≈0.1M parameters)
  Dataset: Fashion-MNIST
  
  Config Content:
  ```yaml
  run_id: proposed-2-Layer-MLP-0.1M-parameters--Fashion-MNIST
method: proposed
algorithm:
  name: CA-BOIL
  n_init_points: 3         # Sobol seed evaluations
  total_evaluations: 40    # 3 initial + 37 BO steps
  cost_model:
    type: gp
    kernel: matern_plus_white
  acquisition:
    type: ei_over_risk_adjusted_cost
    kappa: 1.0             # default; can be tuned by Optuna
    formula: "EI / (mu_c + kappa * sigma_c)"
model:
  name: 2-layer-mlp
  input_dim: 784           # 28×28 images flattened
  hidden_units: 200        # placeholder, will be overridden by Optuna suggestion
  activation: relu
  output_dim: 10
  parameter_budget: "≈0.1M"
dataset:
  name: fashion_mnist
  root: ./data
  train_size: 50000        # 83 % of full train split
  val_size: 10000          # 17 % of full train split
  normalization: true
training:
  epochs: 10               # fixed according to protocol
  batch_size: 128
  optimizer: adam
  weight_decay: 0.0
  max_grad_norm: 1.0
  device: cuda
logging:
  use_wandb: true
  project: ca-boil
  log_interval: 1          # log after each evaluation
resources:
  gpus_per_trial: 1
  gpu_type: A100
  cpus_per_trial: 4
  memory_gb: 16
optuna:
  n_trials: 50
  direction: maximize
  sampler: tpe
  pruner: median
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-1
    hidden_units:
      type: int
      low: 50
      high: 400
      step: 1
    kappa:
      type: uniform
      low: 0.5
      high: 2.0

  ```
  

- Run ID: comparative-1-2-Layer-MLP-0.1M-parameters--Fashion-MNIST
  Method: comparative-1
  Model: 2-Layer MLP (≈0.1M parameters)
  Dataset: Fashion-MNIST
  
  Config Content:
  ```yaml
  run_id: comparative-1-2-Layer-MLP-0.1M-parameters--Fashion-MNIST
method: comparative-1
algorithm:
  name: BOIL
  n_init_points: 3
  total_evaluations: 40
  cost_model:
    type: linear           # original BOIL uses plain LinearRegression
  acquisition:
    type: log_ei_minus_log_cost
    formula: "log(EI) - log(mu_c)"
model:
  name: 2-layer-mlp
  input_dim: 784
  hidden_units: 200        # placeholder, tuned by Optuna
  activation: relu
  output_dim: 10
  parameter_budget: "≈0.1M"
dataset:
  name: fashion_mnist
  root: ./data
  train_size: 50000
  val_size: 10000
  normalization: true
training:
  epochs: 10
  batch_size: 128
  optimizer: adam
  weight_decay: 0.0
  max_grad_norm: 1.0
  device: cuda
logging:
  use_wandb: true
  project: boil-baseline
  log_interval: 1
resources:
  gpus_per_trial: 1
  gpu_type: A100
  cpus_per_trial: 4
  memory_gb: 16
optuna:
  n_trials: 50
  direction: maximize
  sampler: tpe
  pruner: median
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-1
    hidden_units:
      type: int
      low: 50
      high: 400
      step: 1

  ```
  


# Generated Experiment Code (To be validated)
{"config_yaml": "defaults:\n  - _self_\n  - run: ???\n\n# --------------------------- global flags -----------------------------------\nrun:\n  run_id: null  # overwritten by run-config\n\nresults_dir: ./results\ntrial_mode: false\n\n# --------------------------- WandB -----------------------------------------\nwandb:\n  entity: gengaru617-personal\n  project: 251021-test\n  mode: online  # automatically set to \"disabled\" in trial_mode\n\n# --------------------------- placeholders (overwritten) ---------------------\nmethod: \"\"\nalgorithm: {}\nmodel: {}\ndataset: {}\ntraining: {}\noptuna: {}", "evaluate_py": "import argparse\nimport json\nimport os\nfrom itertools import combinations\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml  # Needed for reading stored WandB credentials\nfrom scipy.stats import mannwhitneyu\n\n# --------------------------------------------------------------------------------------\n# Helper utilities\n# --------------------------------------------------------------------------------------\n\ndef ensure_dir(p: Path) -\u003e Path:\n    p.mkdir(parents=True, exist_ok=True)\n    return p\n\n\ndef plot_learning_curve(history_df: pd.DataFrame, run_id: str, out_path: Path) -\u003e None:\n    plt.figure(figsize=(6, 4))\n    if \"cumulative_time\" in history_df.columns and not history_df[\"cumulative_time\"].isnull().all():\n        x = history_df[\"cumulative_time\"]\n    else:\n        x = history_df.index\n    candidate_cols = [\n        \"best_so_far\",\n        \"val_acc\",\n        \"epoch_train_acc\",\n    ]\n    for col in candidate_cols:\n        if col in history_df.columns:\n            plt.plot(x, history_df[col], label=col)\n    plt.xlabel(\"Cumulative Time (s)\" if \"cumulative_time\" in history_df.columns else \"Event Index\")\n    plt.ylabel(\"Accuracy\")\n    plt.title(f\"Learning Curves \u2013 {run_id}\")\n    plt.legend()\n    plt.tight_layout()\n    plt.savefig(out_path, format=\"pdf\")\n    plt.close()\n\n\ndef plot_confusion_matrix(cm: np.ndarray, run_id: str, out_path: Path) -\u003e None:\n    plt.figure(figsize=(6, 5))\n    sns.heatmap(cm, annot=True, fmt=\"d\", cmap=\"Blues\")\n    plt.xlabel(\"Predicted\")\n    plt.ylabel(\"True\")\n    plt.title(f\"Confusion Matrix \u2013 {run_id}\")\n    plt.tight_layout()\n    plt.savefig(out_path, format=\"pdf\")\n    plt.close()\n\n\n# --------------------------------------------------------------------------------------\n# Aggregated analysis \u0026 statistical significance tests\n# --------------------------------------------------------------------------------------\n\ndef run_significance_tests(df: pd.DataFrame, out_dir: Path) -\u003e Path:\n    \"\"\"Perform pairwise Mann\u2013Whitney U tests between methods for each metric.\"\"\"\n    methods = df[\"method\"].unique().tolist()\n    metrics = [col for col in df.columns if col not in {\"run_id\", \"method\"}]\n\n    results: Dict[str, Dict[str, Dict[str, float]]] = {}\n    for m1, m2 in combinations(methods, 2):\n        key = f\"{m1}_vs_{m2}\"\n        results[key] = {}\n        group1 = df[df[\"method\"] == m1]\n        group2 = df[df[\"method\"] == m2]\n        for metric in metrics:\n            x = group1[metric].dropna().values\n            y = group2[metric].dropna().values\n            if len(x) == 0 or len(y) == 0:\n                p_val, statistic = float(\"nan\"), float(\"nan\")\n            else:\n                statistic, p_val = mannwhitneyu(x, y, alternative=\"two-sided\")\n            results[key][metric] = {\n                \"statistic\": float(statistic),\n                \"p_value\": float(p_val),\n            }\n    # Persist to disk\n    ensure_dir(out_dir)\n    out_path = out_dir / \"aggregated_significance_tests.json\"\n    with open(out_path, \"w\", encoding=\"utf-8\") as fp:\n        json.dump(results, fp, indent=2)\n    print(out_path)\n    return out_path\n\n\ndef aggregate_and_compare(all_results: Dict[str, Dict], out_dir: Path) -\u003e None:\n    # Build records table\n    records: List[Dict] = []\n    for run_id, data in all_results.items():\n        summary = data[\"summary\"]\n        config = data[\"config\"]\n        records.append({\n            \"run_id\": run_id,\n            \"method\": config.get(\"method\", \"unknown\"),\n            \"best_val_acc\": summary.get(\"final_best_val_acc\", float(\"nan\")),\n            \"auc\": summary.get(\"auc_accuracy\", float(\"nan\")),\n            \"time_to_85\": summary.get(\"time_to_85\", float(\"nan\")),\n        })\n    df = pd.DataFrame.from_records(records)\n\n    ensure_dir(out_dir)\n    df.to_json(out_dir / \"aggregated_metrics.json\", orient=\"records\", indent=2)\n\n    # ----------- comparison bar chart (best accuracy) ------------------\n    plt.figure(figsize=(8, 4))\n    sns.barplot(x=\"run_id\", y=\"best_val_acc\", hue=\"method\", data=df, dodge=False)\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Best Validation Accuracy\")\n    for i, v in enumerate(df[\"best_val_acc\"].values):\n        plt.text(i, v + 0.001, f\"{v:.3f}\", ha=\"center\", va=\"bottom\", fontsize=7)\n    plt.tight_layout()\n    bar_path = out_dir / \"comparison_best_accuracy_bar_chart.pdf\"\n    plt.savefig(bar_path, format=\"pdf\")\n    plt.close()\n    print(bar_path)\n\n    # Perform statistical significance tests and save results\n    run_significance_tests(df, out_dir)\n\n\n# --------------------------------------------------------------------------------------\n# Main entry point\n# --------------------------------------------------------------------------------------\n\ndef main() -\u003e None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"results_dir\", type=str)\n    parser.add_argument(\n        \"run_ids\",\n        type=str,\n        help=\"JSON string list of run IDs to evaluate e.g. \u0027[\\\"run1\\\", \\\"run2\\\"]\u0027\",\n    )\n    args = parser.parse_args()\n\n    results_dir = Path(args.results_dir).expanduser()\n    run_ids: List[str] = json.loads(args.run_ids)\n\n    # ------------------- load WandB credentials -------------------------\n    with open(results_dir / \"config.yaml\", \"r\", encoding=\"utf-8\") as fp:\n        cfg_wandb = yaml.safe_load(fp)\n    entity = cfg_wandb.get(\"entity\")\n    project = cfg_wandb.get(\"project\")\n\n    api = wandb.Api()\n    all_results: Dict[str, Dict] = {}\n\n    for run_id in run_ids:\n        save_dir = ensure_dir(results_dir / run_id)\n\n        run = api.run(f\"{entity}/{project}/{run_id}\")\n        history = run.history()  # DataFrame with logged metrics\n        summary = run.summary._json_dict\n        config = dict(run.config)\n\n        # --------------------- export full history -----------------------\n        history_path = save_dir / \"metrics.json\"\n        history.to_json(history_path, orient=\"records\", indent=2)\n        print(history_path)\n\n        # --------------------- learning curves --------------------------\n        lc_path = save_dir / f\"{run_id}_learning_curve.pdf\"\n        plot_learning_curve(history, run_id, lc_path)\n        print(lc_path)\n\n        # --------------------- confusion matrix -------------------------\n        if \"confusion_matrix\" in summary:\n            cm_array = np.array(summary[\"confusion_matrix\"])\n            cm_path = save_dir / f\"{run_id}_confusion_matrix.pdf\"\n            plot_confusion_matrix(cm_array, run_id, cm_path)\n            print(cm_path)\n\n        all_results[run_id] = {\"history\": history, \"summary\": summary, \"config\": config}\n\n    # --------------- aggregated analysis \u0026 comparisons -------------------\n    aggregate_dir = results_dir / \"comparison\"\n    aggregate_and_compare(all_results, aggregate_dir)\n    print(aggregate_dir / \"aggregated_metrics.json\")\n\n\nif __name__ == \"__main__\":\n    main()", "main_py": "import subprocess\nimport sys\nfrom pathlib import Path\n\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg: DictConfig):\n    \"\"\"Top-level orchestrator: spawns src.train as subprocess.\"\"\"\n\n    # -------------------- ensure results directory \u0026 store WandB creds --------------------\n    results_dir = Path(cfg.results_dir).expanduser()\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    wandb_cfg_path = results_dir / \"config.yaml\"\n    if not wandb_cfg_path.exists():\n        with open(wandb_cfg_path, \"w\", encoding=\"utf-8\") as fp:\n            fp.write(OmegaConf.to_yaml(cfg.wandb))\n\n    # ------------------------------ compose subprocess cmd ------------------------------\n    cmd = [\n        sys.executable,\n        \"-u\",\n        \"-m\",\n        \"src.train\",\n        f\"run={cfg.run.run_id}\",\n        f\"results_dir={cfg.results_dir}\",\n    ]\n\n    # Trial-mode adjustments\n    if cfg.trial_mode:\n        cmd.append(\"trial_mode=true\")\n        cmd.append(\"wandb.mode=disabled\")\n\n    print(\"[Orchestrator] Executing:\", \" \".join(cmd), flush=True)\n\n    proc = subprocess.Popen(cmd)\n    proc.communicate()\n\n    if proc.returncode != 0:\n        raise SystemExit(proc.returncode)\n\n\nif __name__ == \"__main__\":\n    main()", "model_py": "import torch.nn as nn\n\n\nclass MultiLayerPerceptron(nn.Module):\n    \"\"\"Simple 2-hidden-layer MLP for Fashion-MNIST experiments.\"\"\"\n\n    def __init__(self, input_dim: int, hidden_units: int, output_dim: int, activation: str = \"relu\") -\u003e None:\n        super().__init__()\n        if activation == \"relu\":\n            act_fn = nn.ReLU()\n        elif activation == \"tanh\":\n            act_fn = nn.Tanh()\n        else:\n            raise ValueError(f\"Unsupported activation \u0027{activation}\u0027 \u2013 choose \u0027relu\u0027 or \u0027tanh\u0027.\")\n\n        self.net = nn.Sequential(\n            nn.Flatten(),\n            nn.Linear(input_dim, hidden_units),\n            act_fn,\n            nn.Linear(hidden_units, hidden_units),\n            act_fn,\n            nn.Linear(hidden_units, output_dim),\n        )\n\n    def forward(self, x):  # type: ignore\n        return self.net(x)", "preprocess_py": "from pathlib import Path\nfrom typing import Tuple\n\nimport torch\nfrom torch.utils.data import DataLoader, random_split\nfrom torchvision import datasets, transforms\n\n# Global cache directory for datasets \u0026 models\nCACHE_DIR = Path(\".cache\").absolute()\n\n\ndef get_dataloaders(cfg) -\u003e Tuple[DataLoader, DataLoader, DataLoader]:\n    \"\"\"Return train/val/test DataLoaders following cfg.dataset settings.\"\"\"\n\n    root = CACHE_DIR / cfg.dataset.name\n    root.mkdir(parents=True, exist_ok=True)\n\n    transform_ops = [transforms.ToTensor()]\n    if getattr(cfg.dataset, \"normalization\", True):\n        transform_ops.append(transforms.Normalize((0.5,), (0.5,)))\n    transform = transforms.Compose(transform_ops)\n\n    full_train = datasets.FashionMNIST(root=str(root), train=True, transform=transform, download=True)\n    test_set = datasets.FashionMNIST(root=str(root), train=False, transform=transform, download=True)\n\n    if hasattr(cfg.dataset, \"train_size\") and hasattr(cfg.dataset, \"val_size\"):\n        train_size = cfg.dataset.train_size\n        val_size = cfg.dataset.val_size\n    else:\n        train_size = int(0.83 * len(full_train))\n        val_size = len(full_train) - train_size\n\n    train_subset, val_subset = random_split(\n        full_train, [train_size, val_size], generator=torch.Generator().manual_seed(42)\n    )\n\n    num_workers = 4 if torch.cuda.is_available() else 0\n    pin_memory = torch.cuda.is_available()\n\n    train_loader = DataLoader(\n        train_subset,\n        batch_size=cfg.training.batch_size,\n        shuffle=True,\n        num_workers=num_workers,\n        pin_memory=pin_memory,\n    )\n    val_loader = DataLoader(\n        val_subset,\n        batch_size=cfg.training.batch_size,\n        shuffle=False,\n        num_workers=num_workers,\n        pin_memory=pin_memory,\n    )\n    test_loader = DataLoader(\n        test_set,\n        batch_size=cfg.training.batch_size,\n        shuffle=False,\n        num_workers=num_workers,\n        pin_memory=pin_memory,\n    )\n\n    return train_loader, val_loader, test_loader", "pyproject_toml": "[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n[tool.poetry]\nname = \"ca-boil-experiments\"\nversion = \"0.1.0\"\ndescription = \"Reproducible experiments for CA-BOIL vs. BOIL on Fashion-MNIST\"\nauthors = [\"AI Researcher \u003cresearch@example.com\u003e\"]\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\n# Core\ntorch = \"^2.1.0\"\ntorchvision = \"^0.16.0\"\nhydra-core = \"^1.3.2\"\nomegaconf = \"^2.3.0\"\nwandb = \"^0.16.0\"\n# Optimisation \u0026 analysis\noptuna = \"^3.4.0\"\nscikit-learn = \"^1.3.2\"\nscipy = \"^1.11.3\"\nnumpy = \"^1.26.2\"\npandas = \"^2.1.3\"\nmatplotlib = \"^3.8.0\"\nseaborn = \"^0.13.0\"\ntqdm = \"^4.66.1\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.3\"", "train_py": "import json\nimport os\nimport random\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple\n\nimport hydra\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom omegaconf import DictConfig, OmegaConf\nfrom scipy.stats import norm\nfrom sklearn.metrics import confusion_matrix\nimport wandb\n\nfrom src.model import MultiLayerPerceptron\nfrom src.preprocess import get_dataloaders\n\n# --------------------------------------------------------------------------------------\n# Utility helpers\n# --------------------------------------------------------------------------------------\n\ndef set_seed(seed: int = 42) -\u003e None:\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\ndef ensure_dir(path: Path) -\u003e Path:\n    path.mkdir(parents=True, exist_ok=True)\n    return path\n\n\n# --------------------------------------------------------------------------------------\n# Training of one hyper-parameter setting (inner objective)\n# --------------------------------------------------------------------------------------\n\ndef train_single_model(\n    *,\n    evaluation_index: int,\n    lr: float,\n    hidden_units: int,\n    cfg: DictConfig,\n    loaders: Tuple[torch.utils.data.DataLoader, torch.utils.data.DataLoader],\n    device: torch.device,\n) -\u003e Tuple[Dict, float]:\n    \"\"\"Train a 2-layer MLP for *cfg.training.epochs* epochs and return metrics + runtime.\"\"\"\n\n    start_time = time.perf_counter()\n\n    train_loader, val_loader = loaders\n    model = MultiLayerPerceptron(\n        input_dim=cfg.model.input_dim,\n        hidden_units=hidden_units,\n        output_dim=cfg.model.output_dim,\n        activation=cfg.model.activation,\n    ).to(device)\n\n    criterion = nn.CrossEntropyLoss()\n    optimizer = optim.Adam(model.parameters(), lr=lr, weight_decay=cfg.training.weight_decay)\n\n    best_val_acc: float = 0.0\n    cm_best: np.ndarray | None = None\n\n    global_step = 0  # wandb global step counter\n    for epoch in range(cfg.training.epochs):\n        model.train()\n        running_loss = 0.0\n        running_correct = 0\n        running_total = 0\n\n        for batch_idx, (inputs, targets) in enumerate(train_loader):\n            if cfg.trial_mode and batch_idx \u003e= 2:\n                break  # Reduce compute in trial mode\n\n            inputs, targets = inputs.to(device), targets.to(device)\n            optimizer.zero_grad()\n            outputs = model(inputs)\n            loss = criterion(outputs, targets)\n            loss.backward()\n            nn.utils.clip_grad_norm_(model.parameters(), cfg.training.max_grad_norm)\n            optimizer.step()\n\n            running_loss += loss.item() * inputs.size(0)\n            _, preds = outputs.max(1)\n            running_correct += preds.eq(targets).sum().item()\n            running_total += targets.size(0)\n\n            if cfg.wandb.mode != \"disabled\":\n                wandb.log(\n                    {\n                        \"evaluation_index\": evaluation_index,\n                        \"epoch\": epoch,\n                        \"batch\": batch_idx,\n                        \"train_loss\": loss.item(),\n                    },\n                    commit=False,\n                )\n            global_step += 1\n\n        epoch_train_loss = running_loss / running_total\n        epoch_train_acc = running_correct / running_total\n\n        # ----------------------------- validation -----------------------------\n        model.eval()\n        val_correct, val_total = 0, 0\n        all_true: List[int] = []\n        all_pred: List[int] = []\n        with torch.no_grad():\n            for batch_idx, (inputs, targets) in enumerate(val_loader):\n                if cfg.trial_mode and batch_idx \u003e= 2:\n                    break\n                inputs, targets = inputs.to(device), targets.to(device)\n                outputs = model(inputs)\n                _, preds = outputs.max(1)\n                val_correct += preds.eq(targets).sum().item()\n                val_total += targets.size(0)\n                all_true.extend(targets.cpu().tolist())\n                all_pred.extend(preds.cpu().tolist())\n        val_acc = val_correct / val_total\n\n        if val_acc \u003e best_val_acc:\n            best_val_acc = val_acc\n            cm_best = confusion_matrix(all_true, all_pred, labels=list(range(cfg.model.output_dim)))\n            best_state_dict = model.state_dict()\n\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log(\n                {\n                    \"evaluation_index\": evaluation_index,\n                    \"epoch\": epoch,\n                    \"epoch_train_loss\": epoch_train_loss,\n                    \"epoch_train_acc\": epoch_train_acc,\n                    \"val_acc\": val_acc,\n                },\n                commit=True,\n            )\n\n    runtime = time.perf_counter() - start_time\n\n    # Ensure confusion matrix exists even if never updated (edge-case)\n    if cm_best is None:\n        cm_best = confusion_matrix(all_true, all_pred, labels=list(range(cfg.model.output_dim)))\n\n    metrics = {\n        \"best_val_accuracy\": best_val_acc,\n        \"confusion_matrix\": cm_best.tolist(),\n    }\n    return metrics, runtime\n\n\n# --------------------------------------------------------------------------------------\n# Acquisition helpers\n# --------------------------------------------------------------------------------------\n\ndef expected_improvement(mu: np.ndarray, sigma: np.ndarray, y_best: float) -\u003e np.ndarray:\n    sigma = np.maximum(sigma, 1e-9)\n    z = (mu - y_best) / sigma\n    ei = (mu - y_best) * norm.cdf(z) + sigma * norm.pdf(z)\n    return ei\n\n\ndef area_under_curve(xs: np.ndarray, ys: np.ndarray) -\u003e float:\n    return np.trapz(ys, xs)\n\n\ndef first_time_reach(acc_list: List[float], time_stamps: List[float], threshold: float = 0.85) -\u003e float:\n    for acc, t in zip(acc_list, time_stamps):\n        if acc \u003e= threshold:\n            return t\n    return float(\"inf\")\n\n\n# --------------------------------------------------------------------------------------\n# BOIL optimiser\n# --------------------------------------------------------------------------------------\n\ndef run_boil(cfg: DictConfig, loaders, device):\n    from sklearn.gaussian_process import GaussianProcessRegressor\n    from sklearn.gaussian_process.kernels import Matern, WhiteKernel\n    from sklearn.linear_model import LinearRegression\n\n    # Search-space bounds in log10 space for lr, integer for hidden_units\n    bounds = np.array([\n        [np.log10(cfg.optuna.search_space.learning_rate.low), np.log10(cfg.optuna.search_space.learning_rate.high)],\n        [cfg.optuna.search_space.hidden_units.low, cfg.optuna.search_space.hidden_units.high],\n    ])\n\n    def sample_random(n: int) -\u003e np.ndarray:\n        lr = 10 ** np.random.uniform(bounds[0, 0], bounds[0, 1], size=n)\n        hidden = np.random.randint(bounds[1, 0], bounds[1, 1] + 1, size=n)\n        return np.stack([lr, hidden], axis=1)\n\n    n_init = cfg.algorithm.n_init_points\n    total_evals = 1 if cfg.trial_mode else cfg.algorithm.total_evaluations\n\n    X: List[np.ndarray] = []\n    y_u: List[float] = []\n    y_c: List[float] = []\n    cumulative_time: float = 0.0\n    cumulative_times: List[float] = []\n    best_so_far = 0.0\n\n    utility_gp = GaussianProcessRegressor(kernel=Matern() + WhiteKernel(1e-5))\n    cost_model = LinearRegression()\n\n    for eval_idx in range(total_evals):\n        # --------------------------- propose ---------------------------\n        if eval_idx \u003c n_init or len(X) \u003c 2:\n            x_next = sample_random(1)[0]\n        else:\n            utility_gp.fit(np.array(X), np.array(y_u))\n            cost_model.fit(np.array(X), np.array(y_c))\n            cand = sample_random(4000)\n            mu_u, sigma_u = utility_gp.predict(cand, return_std=True)\n            mu_c = cost_model.predict(cand)\n            ei = expected_improvement(mu_u, sigma_u, max(y_u))\n            acq = np.log(ei + 1e-12) - np.log(mu_c + 1e-12)\n            x_next = cand[np.argmax(acq)]\n\n        lr, hidden = float(x_next[0]), int(round(x_next[1]))\n\n        # --------------------------- evaluate --------------------------\n        metrics, wall_clock = train_single_model(\n            evaluation_index=eval_idx,\n            lr=lr,\n            hidden_units=hidden,\n            cfg=cfg,\n            loaders=loaders,\n            device=device,\n        )\n        val_acc = metrics[\"best_val_accuracy\"]\n\n        # --------------------------- bookkeeping -----------------------\n        cumulative_time += wall_clock\n        cumulative_times.append(cumulative_time)\n        X.append(x_next)\n        y_u.append(val_acc)\n        y_c.append(np.log(wall_clock))\n        best_so_far = max(best_so_far, val_acc)\n\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log(\n                {\n                    \"evaluation\": eval_idx,\n                    \"lr\": lr,\n                    \"hidden_units\": hidden,\n                    \"val_acc\": val_acc,\n                    \"best_so_far\": best_so_far,\n                    \"cumulative_time\": cumulative_time,\n                    \"wall_clock\": wall_clock,\n                }\n            )\n\n    # ------------------------ aggregate metrics ---------------------------\n    auc = area_under_curve(np.arange(len(y_u)), np.asarray(y_u))\n    t85 = first_time_reach(y_u, cumulative_times, threshold=0.85)\n\n    if cfg.wandb.mode != \"disabled\":\n        wandb.summary[\"final_best_val_acc\"] = best_so_far\n        wandb.summary[\"auc_accuracy\"] = auc\n        wandb.summary[\"time_to_85\"] = t85\n        wandb.summary[\"confusion_matrix\"] = metrics[\"confusion_matrix\"]\n\n\n# --------------------------------------------------------------------------------------\n# CA-BOIL optimiser\n# --------------------------------------------------------------------------------------\n\ndef run_ca_boil(cfg: DictConfig, loaders, device):\n    from sklearn.gaussian_process import GaussianProcessRegressor\n    from sklearn.gaussian_process.kernels import Matern, WhiteKernel\n\n    bounds = np.array([\n        [np.log10(cfg.optuna.search_space.learning_rate.low), np.log10(cfg.optuna.search_space.learning_rate.high)],\n        [cfg.optuna.search_space.hidden_units.low, cfg.optuna.search_space.hidden_units.high],\n    ])\n\n    def sample_random(n: int) -\u003e np.ndarray:\n        lr = 10 ** np.random.uniform(bounds[0, 0], bounds[0, 1], size=n)\n        hidden = np.random.randint(bounds[1, 0], bounds[1, 1] + 1, size=n)\n        return np.stack([lr, hidden], axis=1)\n\n    n_init = cfg.algorithm.n_init_points\n    total_evals = 1 if cfg.trial_mode else cfg.algorithm.total_evaluations\n    kappa = cfg.algorithm.acquisition.kappa\n\n    X: List[np.ndarray] = []\n    y_u: List[float] = []\n    y_c: List[float] = []\n    cumulative_time: float = 0.0\n    cumulative_times: List[float] = []\n    best_so_far = 0.0\n\n    utility_gp = GaussianProcessRegressor(kernel=Matern() + WhiteKernel(1e-5))\n    cost_gp = GaussianProcessRegressor(kernel=Matern() + WhiteKernel(1e-5))\n\n    for eval_idx in range(total_evals):\n        # --------------------------- suggest ---------------------------\n        if eval_idx \u003c n_init or len(X) \u003c 3:\n            x_next = sample_random(1)[0]\n        else:\n            utility_gp.fit(np.array(X), np.array(y_u))\n            cost_gp.fit(np.array(X), np.array(y_c))\n            cand = sample_random(4000)\n            mu_u, sigma_u = utility_gp.predict(cand, return_std=True)\n            mu_c, sigma_c = cost_gp.predict(cand, return_std=True)\n            ei = expected_improvement(mu_u, sigma_u, max(y_u))\n            acq = ei / (mu_c + kappa * sigma_c + 1e-12)\n            x_next = cand[np.argmax(acq)]\n\n        lr, hidden = float(x_next[0]), int(round(x_next[1]))\n\n        # --------------------------- evaluate --------------------------\n        metrics, wall_clock = train_single_model(\n            evaluation_index=eval_idx,\n            lr=lr,\n            hidden_units=hidden,\n            cfg=cfg,\n            loaders=loaders,\n            device=device,\n        )\n        val_acc = metrics[\"best_val_accuracy\"]\n\n        # --------------------------- bookkeeping -----------------------\n        cumulative_time += wall_clock\n        cumulative_times.append(cumulative_time)\n        X.append(x_next)\n        y_u.append(val_acc)\n        y_c.append(np.log(wall_clock))\n        best_so_far = max(best_so_far, val_acc)\n\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log(\n                {\n                    \"evaluation\": eval_idx,\n                    \"lr\": lr,\n                    \"hidden_units\": hidden,\n                    \"val_acc\": val_acc,\n                    \"best_so_far\": best_so_far,\n                    \"cumulative_time\": cumulative_time,\n                    \"wall_clock\": wall_clock,\n                }\n            )\n\n    auc = area_under_curve(np.arange(len(y_u)), np.asarray(y_u))\n    t85 = first_time_reach(y_u, cumulative_times, threshold=0.85)\n\n    if cfg.wandb.mode != \"disabled\":\n        wandb.summary[\"final_best_val_acc\"] = best_so_far\n        wandb.summary[\"auc_accuracy\"] = auc\n        wandb.summary[\"time_to_85\"] = t85\n        wandb.summary[\"confusion_matrix\"] = metrics[\"confusion_matrix\"]\n\n\n# --------------------------------------------------------------------------------------\n# Main entry point for a single experiment run\n# --------------------------------------------------------------------------------------\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg: DictConfig):\n    \"\"\"Entry point executed by src.main orchestrator.\"\"\"\n\n    # ------------------------- trial-mode adjustments -------------------------\n    if cfg.trial_mode:\n        cfg.wandb.mode = \"disabled\"\n        cfg.training.epochs = 1\n        cfg.algorithm.total_evaluations = 1\n        cfg.optuna.n_trials = 0\n\n    # -------------------------- directories \u0026 seeding -------------------------\n    results_root = ensure_dir(Path(cfg.results_dir).expanduser())\n    run_dir = ensure_dir(results_root / cfg.run.run_id)\n    set_seed(42)\n\n    # -------------------------- WandB initialisation --------------------------\n    if cfg.wandb.mode != \"disabled\":\n        wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run.run_id,\n            config=OmegaConf.to_container(cfg, resolve=True),\n            resume=\"allow\",\n            mode=cfg.wandb.mode,\n            dir=str(run_dir),\n        )\n        print(\"WandB URL:\", wandb.run.get_url(), flush=True)\n    else:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n\n    # --------------------------- data pipeline ------------------------------\n    device = torch.device(\"cuda\" if torch.cuda.is_available() and cfg.training.device == \"cuda\" else \"cpu\")\n    train_loader, val_loader, _ = get_dataloaders(cfg)\n\n    # ---------------------------- run optimiser ----------------------------\n    if cfg.algorithm.name.lower() == \"boil\":\n        run_boil(cfg, (train_loader, val_loader), device)\n    elif cfg.algorithm.name.lower() in {\"ca-boil\", \"ca_boil\", \"caboil\"}:\n        run_ca_boil(cfg, (train_loader, val_loader), device)\n    else:\n        raise ValueError(f\"Unsupported algorithm name {cfg.algorithm.name}\")\n\n    # ------------------- persist WandB creds for evaluator ------------------\n    config_path = results_root / \"config.yaml\"\n    if not config_path.exists():\n        with open(config_path, \"w\", encoding=\"utf-8\") as fp:\n            fp.write(OmegaConf.to_yaml(cfg.wandb))\n\n    # Optionally save best model checkpoint (if best_state_dict present)\n    if \"best_state_dict\" in locals():\n        torch.save(best_state_dict, run_dir / \"best_model.pt\")\n\n    if cfg.wandb.mode != \"disabled\":\n        wandb.finish()\n\n\nif __name__ == \"__main__\":\n    main()"}

Analyze the experiment code thoroughly. Ensure it is complete, executable, and ready for publication-quality research experiments.
Output:
{
    "is_code_ready": false,
    "code_issue": "Evaluation script does not fulfil the mandatory aggregated-analysis requirements: it creates aggregated_metrics.json and a single bar chart, but it never computes / writes secondary derived metrics such as improvement-rate ((proposed – baseline)/baseline) and produces no cross-run comparison charts (box plots, etc.). Therefore criterion 8 (STEP 2) is not fully satisfied, so the code is not yet ready for immediate execution."
}
